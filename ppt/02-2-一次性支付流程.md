這份逐字稿已經經過修潤，移除了過於中二的「戰術室」用語，轉為**「資深開發者 (Senior Developer)」**的專業語氣，但保留了易懂的教學口吻。我將重點放在**「職責分離 (Separation of Concerns)」**與**「資料可信度 (Data Reliability)」**上。

這份稿子你可以直接照著唸，語氣保持沈穩、專業即可。

---

### 🎙️ Chapter 2-2：工程藍圖 — 一次性支付的標準流程

**【Slide 1：官方流程圖的盲點】**
*   **視覺畫面**：左邊顯示 **PAYUNi UPP 信用卡交易流程圖**。右邊標題打上：「開發者的視角 (The Developer's View)」。
*   **逐字稿**：
    嗨，大家好，我是 Cab。歡迎來到 Chapter 2-2。

    現在螢幕上這張圖，是統一金流官方提供的標準流程圖。
    如果你是產品經理 (PM) 或是老闆，這張圖非常完美：使用者付款，資料送到金流商，銀行授權，最後把結果回傳給商店。邏輯完全正確。

    但在我們這些負責寫程式的開發者眼裡，這張圖其實少了一個最關鍵的細節。
    請看中間這個「收款商店 (Merchant)」的方塊。官方把它畫成了一個單一的角色。
    但在現代的 Web 開發架構中，我們很清楚，這個方塊其實是由兩個完全不同的世界組成的：也就是使用者的「瀏覽器前端」，以及我們控制的「後端伺服器」。

    如果不把這兩個角色拆開來看，新手很容易就會照著這張圖，把金流的 API Key 寫在前端，或是錯誤地依賴前端轉址來判定交易成功。

    所以這一節，我們要做的就是把這張官方圖表「解壓縮」，轉化成一張真正能用來寫程式的「時序圖 (Sequence Diagram)」。我們開始吧。

---

#### **【Slide 2：角色映射與職責定義】**
*   **視覺畫面**：動畫淡出官方圖，出現標準時序圖的三個泳道（User/Browser, Backend Server, Gateway）。
*   **逐字稿**：
    首先，我們重新定義這場戲的三個主角。

    第一，官方圖裡的「付款人」，在工程上對應的就是**「使用者的瀏覽器 (Browser)」**。
    這個環境是不可信的 (Untrusted)，使用者隨時可能斷網、關閉視窗，甚至惡意修改前端代碼。

    第二，官方圖裡的「收款商店」，對應的是你的**「後端伺服器 (Backend Server)」**。
    這裡才是系統的大腦，也是唯一能存放 API Key 和資料庫的地方。

    第三，右邊的統一金流與銀行，我們統稱為 **Gateway (金流閘道)**。
    對我們來說，它就是一個黑盒子，我們只需要知道怎麼把資料丟進去，以及怎麼接收它的回傳結果就好。

    把這三條線畫出來，釐清了誰該做什麼事，我們就可以開始跑流程了。

---

#### **【Slide 3：交易初始化 (Step 1 & 2)】**
*   **視覺畫面**：聚焦在 Browser 與 Server 之間的互動。箭頭：Create Order -> Save DB -> Sign -> Return Form。
*   **逐字稿**：
    我們來看官方圖的 **Step 1 (確認付款)** 和 **Step 2 (傳遞交易參數)**。
    這兩個步驟之間，其實發生了很重要的後端邏輯。

    當使用者在網頁上按下「立即結帳」時，資料並不是直接飛到金流商那邊。
    第一步，瀏覽器必須先發送請求給你的 Server，說：「我要建立一筆訂單」。

    這時候，你的 Server 要做兩件事：
    首先，在資料庫建立一筆訂單，並將狀態標記為 `Created` (未付款)。
    接著，是最重要的一步：Server 必須把訂單金額、訂單編號等資料打包，並且加上一個**「數位簽章 (Digital Signature)」**。

    這時候 Server 會把這些訂單資料加密打包。至於這包加密資料裡面具體要放什麼欄位、變數名稱叫什麼，那是下一章我們看文件時要處理的細節。現在我們先把它想像成一個「封好的機密包裹」就好，重點是它已經被你的 Server 簽名認證過了。

    Server 把這個包裹回傳給前端，這時候，我們才真正準備好要進行下一步的跳轉。

---

#### **【Slide 4：前端跳轉與託管 (Step 3)】**
*   **視覺畫面**：Browser 自動 Submit Form 到 Gateway。標示 User 此時位於金流頁面。
*   **逐字稿**：
    接著，瀏覽器拿到 Server 給的加密包裹後，會自動執行一個 Form Submit 的動作，將使用者「導向」統一金流的付款頁面。這對應到官方圖的 **Step 3**。

    在這個階段，使用者是在金流商的網頁上輸入卡號。
    這對開發者來說是一個巨大的優勢：因為信用卡號從頭到尾都沒有經過你的伺服器，所以你完全不需要煩惱 PCI-DSS 那些複雜的資安合規問題。

    而在這段時間，你的 Server 在做什麼呢？
    答案是：**什麼都不做，靜靜等待**。因為控制權現在在金流商手上。

---

#### **【Slide 5：關鍵分流 — Redirect vs Webhook (Step 6 & 7)】**
*   **視覺畫面**：Gateway 發出兩條箭頭。一條指回 Browser (Redirect)，一條指回 Server (Webhook)。**這是本節重點。**
*   **逐字稿**：
    好，假設使用者刷卡成功了。接下來是整張圖最關鍵、也是最多開發者容易混淆的地方。
    請看到官方圖的 **Step 6-2** 和 **Step 7**。這兩條線看起來都是「回傳結果」，但在系統設計上，它們的意義完全不同。

    上方這條 **Step 7 叫做 Redirect (網頁跳轉)**。
    這是金流商把使用者「送回」你的網站，目的是為了讓使用者看到「謝謝購買」的頁面，這是一個**使用者體驗 (UX)** 的流程。
    但是請注意，使用者可能刷完卡剛好手機沒電，或者覺得已經買到了就直接關閉視窗。這意味著，**Redirect 這個步驟是有可能根本不會發生的**。

    下方這條 **Step 6-2 叫做 Webhook (幕後通知)**。
    這才是金流商真正用來「交付收據」的方式。它會從金流商的伺服器，直接發送 HTTP 請求給你的後端 Server。不管使用者有沒有關視窗，只要交易成功，這條訊號一定會送出來。

    所以，作為一個專業的開發者，**我們更新資料庫、發送商品序號的依據，絕對只能是 Webhook**，而不能依賴前端的 Redirect。

    此外，當 Server 收到這個 Webhook 通知時，我們必須再次檢查上面的數位簽章是否正確，確保資料沒有被中間人竄改過。
    關於如果不檢查會發生什麼可怕的事，以及駭客具體怎麼攻擊，我們會在 **Chapter 4** 專門用一個章節來演練這場攻防戰，這邊我們先記住「驗證」是必須的步驟就好。

---

#### **【Slide 6：總結與預告】**
*   **視覺畫面**：展示一張完整的 Sequence Diagram，標註了剛剛講的所有步驟。
*   **逐字稿**：
    我們把剛剛拆解的步驟重新組裝起來，這就是你現在螢幕上看到的工程藍圖。

    這張圖跟官方流程圖講的事情是一樣的，但現在層次更分明了：
    1.  我们在 Server 端建立訂單並簽名。
    2.  前端負責跳轉，不處理業務邏輯。
    3.  最後透過 Webhook 來確認交易結果，而不是依賴前端頁面。

    這張圖就是一般「一次性支付」的標準模型。

    這時候你也許會問：「那如果是像 Netflix 那樣每個月自動扣款呢？」
    那個流程會稍微複雜一點，因為第二次以後的扣款就不需要使用者介入了，這會用到一個叫「父子單」的概念。
    大家先把這張基礎地圖記熟，下一章 **Chapter 2-3**，我會專門來拆解訂閱制的變形版本。

    我們下一章見。