# 設計理念與 AI 協作指南

本文檔旨在闡述「金流整合實戰包」背後的設計哲學、安全架構，並提供如何與 AI 高效協作以進行安全客製化的指南。

## Part 1: 我們的設計哲學：為何選擇 Google Sheets？

當您第一眼看到這個專案使用 Google Sheets 作為資料庫時，專業的開發者可能會感到疑惑：「為什麼不使用更專業的 PostgreSQL 或 MongoDB？」

**答案是：這是一個刻意的、以使用者為中心的設計選擇。**

我們的核心目標客群是個人創作者、Vibe Coder、以及想快速啟動專案的技術自學者。對這個群體而言，最優先的考量是：

1.  **零成本與零維護**：您無需申請、設定、或為任何資料庫服務付費。您不必擔心資料庫的備份、擴容或安全更新。它就是能用，而且是免費的。
2.  **高易用性**：幾乎每個人都熟悉 Google Sheets 的介面。您可以非常直觀地進行訂單檢視、手動標記出貨狀態、或進行簡單的統計分析，無需學習任何 SQL 或資料庫查詢語言。
3.  **高整合性**：透過我們提供的 n8n/gas 範本，Google Sheets 可以輕鬆地與您生態系統中的其他工具（如 Gmail, Airtable, Slack, Line 等）進行對接，實現各種自動化流程。

### 未來的擴展性

我們完全理解，當您的業務成長到一定規模時，可能會需要更專業的資料庫。

本專案的架構是**模組化**的。在 `index.js` 中，所有與 Google Sheets 互動的邏輯都被封裝在特定的 `try...catch` 區塊中。在我們的「深度導讀講座」中，我們會詳細說明，如果您未來需要更換成專業資料庫，應該修改哪幾個部分，以及如何指導 AI 安全地完成這個任務。

**總結：我們選擇了最適合起步的方案，並為您未來的成長預留了清晰的路徑。**

---

## Part 2: 安全架構解析：不只是能動，更是安全

本專案不僅僅是串接 API，更是一個多層次的安全防禦體系。以下是我們為您內建的關鍵安全機制：

### 2.1 HTTP 安全標頭 (Helmet)
- **作用**：透過設定各種 HTTP 標頭，為您的網站增加一層基礎防護，有效防禦如跨站腳本攻擊 (XSS)、點擊劫持 (Clickjacking) 等常見威脅。
- **價值**：您無需成為資安專家，就能獲得一個業界標準的安全基線。

### 2.2 跨域資源共享 (CORS)
- **作用**：嚴格限制只有在白名單中的來源（您的前端網站、Payuni 伺服器）才能存取您的後端 API。
- **價值**：防止惡意網站隨意呼叫您的 API，造成資源浪費或潛在攻擊。

### 2.3 速率限制 (Rate Limiting)
- **作用**：針對不同類型的請求（一般訪問、建立支付），設定了不同的請求頻率上限。
- **價值**：有效防止惡意的機器人程式透過大量請求癱瘓您的服務（阻斷服務攻擊, DoS）。

### 2.4 跨站請求偽造防護 (CSRF)
- **作用**：確保所有會修改資料的請求（如建立支付），都必須附帶一個由伺服器簽發的一次性令牌 (Token)。
- **價值**：防禦 CSRF 攻擊，避免攻擊者誘騙已登入的使用者，在不知情的情況下執行惡意操作。

### 2.5 輸入驗證 (Express Validator)
- **作用**：對所有來自前端的輸入（如 Email 格式）進行嚴格的格式與長度檢查。
- **價值**：確保進入您系統的資料是乾淨、有效的，防止惡意輸入或格式錯誤導致的後端錯誤。

### 2.6 敏感日誌過濾 (Winston)
- **作用**：在記錄系統日誌時，自動將信用卡號、密鑰等敏感資訊替換為 `***REDACTED***`。
- **價值**：即使日誌文件不慎外洩，也能確保最核心的敏感資料不會暴露，遵循了「縱深防禦」的原則。

---

## Part 4: 核心流程設計解析 (v2 - 含使用者登入)

一個完整的金流交易包含兩個核心流程：「前端支付請求」與「後端 Webhook 通知」。在新版中，我們加入了**強制使用者登入**的步驟，大幅提升了交易的安全性與可追溯性。

### 4.1 流程一：前端支付請求 (使用者發起交易)

這個流程處理的是從使用者登入、點擊「購買」按鈕，到被導向至 Payuni 付款頁面的過程。

```mermaid
graph TD
    subgraph "使用者端"
        A[1. 使用者以 Google 帳號登入] --> B[2. 點擊購買];
        B --> C[3. 獲取人機驗證 Token];
        C --> D[4. 攜帶 CSRF Token 發送請求];
    end
    
    subgraph "伺服器端"
        E{後端 /create-payment};
        D --> E;
        E --> F[5. 驗證使用者已登入 (Session)];
        F --> G[6. 驗證 CSRF Token];
        G --> H[7. 驗證人機驗證 Token];
        H --> I[8. 從 Session 獲取 Email];
        I --> J[9. 建立/查找訂單];
        J --> K[10. 加密與簽名];
        K --> L[11. 回傳加密資料給前端];
    end

    subgraph "使用者端 (續)"
        L --> M{前端 JS};
        M --> N[12. 動態建立表單並自動提交];
        N --> O[跳轉至 Payuni 付款頁];
    end

    style A fill:#f9f,stroke:#333,stroke-width:2px
    style O fill:#f9f,stroke:#333,stroke-width:2px
    style E fill:#ccf,stroke:#333,stroke-width:2px
```

**各步驟安全考量**：
1.  **使用者登入**：這是 v2 架構的**核心安全升級**。它確保了每一筆交易都能對應到一個真實的使用者身份，極大增強了交易的可追溯性，並為後續的訂單查詢功能打下基礎。
2.  **點擊購買**：使用者發起操作。
3.  **人機驗證 (Turnstile)**：防止惡意機器人大量、自動地發起支付請求，消耗您的伺服器資源。
4.  **CSRF Token**：確保這個「建立支付」的請求，是從您自己的網站發出的，而非來自一個偽造的惡意網站。
5.  **驗證使用者已登入**：後端的**第一道防線**。透過檢查伺服器 `session`，確認操作者是合法的登入使用者。
6.  **驗證 CSRF Token**：後端的**第二道防線**，如果 Token 不符，立即拒絕請求。
7.  **驗證人機驗證 Token**：後端的**第三道防線**，在伺服器端再次確認使用者不是機器人。
8.  **從 Session 獲取 Email**：**極其重要的安全實踐**。直接從伺服器端、受保護的 `session` 中獲取使用者 Email，而不是信任任何來自前端的輸入。這徹底杜絕了攻擊者偽造他人 Email 進行下單的風險。
9.  **建立/查找訂單**：與您的資料來源 (Google Sheets) 互動，為交易建立一個唯一的紀錄。
10. **加密與簽名 (AES/SHA256)**：將所有交易資料加密，確保在傳輸過程中不被竊聽；同時生成簽名，確保資料不被竄改。
11. **回傳加密資料**：只將加密後的資料回傳給前端。
12. **動態建立表單**：前端收到加密資料後，動態產生一個表單並提交到 Payuni 的網址。

### 4.2 流程二：後端 Webhook 通知 (金流方確認交易)

這個流程**維持不變**，它獨立於使用者登入狀態，是伺服器與伺服器之間的通訊，其安全性依賴於嚴格的簽名驗證。

```mermaid
graph TD
    P[使用者在 Payuni 完成付款] --> Q{Payuni 伺服器};
    Q --> R[1. 向您的 Webhook URL 發送 POST 請求];
    R --> S{後端 /payuni-webhook};
    S --> T[2. 驗證 Hash 簽名];
    T --> U[3. 解密交易資料];
    U --> V[4. 驗證資料完整性];
    V --> W[5. 更新資料庫訂單狀態];
    W --> X[6. 回應 "OK" 給 Payuni];

    style P fill:#f9f,stroke:#333,stroke-width:2px
    style Q fill:#f9f,stroke:#333,stroke-width:2px
    style S fill:#ccf,stroke:#333,stroke-width:2px
```

**各步驟安全考量**：
1.  **Webhook URL**：這個 URL 必須是**公開的**，但它的安全性不依賴於隱藏 URL，而是依賴於接下來的驗證步驟。
2.  **驗證 Hash 簽名**：這是 Webhook 的**第一道也是最重要的防線**。透過比對您自己計算的簽名與 Payuni 送來的簽名，您可以 100% 確認這個請求的確是來自 Payuni，且內容未被竄改。
3.  **解密交易資料**：簽名驗證通過後，才能安全地解密，獲取真實的訂單編號、金額、狀態等資訊。
4.  **驗證資料完整性**：檢查解密後的資料是否包含必要的欄位（如訂單編號）。
5.  **更新資料庫訂單狀態**：根據解密後的資訊，更新您自己的訂單紀錄。這是您判斷是否要出貨、提供服務的**最終依據**。
6.  **回應 "OK"**：向 Payuni 的伺服器回傳一個簡單的成功訊息，告知它您已成功收到並處理了這個通知。
