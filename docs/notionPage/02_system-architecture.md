# 系統架構：怎麼運作

> 6 個核心元件 + 3 個完整流程 + 多層防線

---

## 📖 這一頁是什麼

這一章是你進入「金流架構思維實戰教學包」的核心觀察地點。透過這份架構圖與流程拆解，我們不只是讓你知道鏈接了哪些服務，而是希望你能直接練習「如何看懂一個系統、分辨每一層的責任、以及何時要加一道防線」。

理解各個環節如何互動後，你就能清楚判斷該在哪裡放驗證、該在哪裡監控、該如何延伸成下一個能力型專案。同時也是後續進行客製化與功能擴充的關鍵。

**預期耗時：** 15 分鐘  
**你將學到：** 6 個核心元件、信任邊界、三大流程、防線設計

---

## 📚 閱讀順序建議

✅ **已讀** `設計理念` - 了解「為什麼」設計成這樣

⏳ **正在讀** 本文 - 了解「具體怎麼做」

🔜 **接著根據需求深入**
- 關注安全細節？ → `安全機制`
- 想自己實作？ → `動手實踐`

---

## 1️⃣ 核心元件拆解

我們的系統主要由以下幾個核心元件組成：

| 元件 | 技術/服務 | 扮演的角色 |
|------|---------|---------|
| **前端** | HTML, CSS, JavaScript | **使用者介面**：呈現商品、處理 Google 登入、觸發購買流程、跳轉 Payuni 支付頁面、顯示支付結果。 |
| **後端** | Node.js / Express.js | **伺服器中心**：串連所有服務的核心，負責處理業務邏輯、驗證與安全性。 |
| **支付閘道** | Payuni API | **金流方**：接收訂單資訊並建立付款頁面，於金流方平台進行實際的支付流程，我們的系統不經手任何支付過程。 |
| **身份驗證** | Google OAuth 2.0 | **使用者身份**：提供一個安全、可信賴的第三方登入機制，避免惡意註冊。 |
| **人機驗證** | Cloudflare Turnstile | **機器人防護**：以對使用者友善的方式，過濾惡意機器人流量。 |
| **資料庫** | Google Apps Script + Sheet | **訂單儲存**：一個無伺服器、高可用性且免費的訂單儲存解決方案。 |

### 🔍 元件責任與信任邊界

讀完上表，你會注意到每個元件都「只做自己的事」。這正是「關注點分離」的體現。

| 元件 | 它負責什麼 | 它不負責什麼 | 為什麼這樣分工 |
|------|----------|-----------|------------|
| **前端** | 呈現、收集使用者輸入、呼叫 API | 驗證、加密、儲存敏感資料 | 前端可被篡改，不能信任 |
| **後端** | 驗證、加密、業務邏輯 | 呈現介面、直接處理支付 | 後端可信，但要與支付隔離 |
| **Payuni** | 支付流程、金鑰管理 | 驗證訂單、修改金額 | 金流方專注金流 |
| **資料庫** | 儲存最終結果 | 驗證訂單、加密敏感資料 | 資料庫只是倉庫 |

**核心啟示：** 當每個部分只做一件事且做好時，系統更容易理解、測試和維護。

---

## 2️⃣ 三大核心流程詳解

理解以下三個核心流程，您就能掌握整個系統的運作精髓。

### 流程一：使用者登入 (Google OAuth 2.0)

#### 情境提要

想像顧客來到店裡，我們需要知道他是誰（至少要是人），於是他在消費之前須要登入 Google 驗證身份。

驗證完畢後，Google 會給顧客一串**『驗證碼』**（Authorization Code），並讓他帶回來交給我們的後台。

我們伺服器收到這串驗證碼後，會**再次**跟 Google 確認是否有效，確認無誤後，**才會發給顧客一張允許消費的『通行證』（Session Cookie）**。

#### 流程圖

```
1. 使用者點擊「使用 Google 登入」
   ↓
2. 前端重導向至 Google 驗證頁面
   ↓
3. 使用者在 Google 登入並授權
   ↓
4. Google 重導向至後端 Callback URL，附帶授權碼
   ↓
5. 後端向 Google 交換 Access Token
   ↓
6. 取得使用者資料（名稱、頭像等）
   ↓
7. 後端建立 Session，發送 Session Cookie
   ↓
8. 重導向至首頁，前端顯示使用者資訊
```

#### 7 個執行步驟

1. **觸發**：使用者在 `index.html` 上點擊「使用 Google 登入」。
2. **重導向至 Google**：瀏覽器被導向至 Google 的身份驗證頁面。
3. **使用者授權**：使用者在 Google 頁面登入並同意授權。
4. **回呼**：Google 將使用者導回至我們後端設定的 Callback URL (`/auth/google/callback`)，並附帶授權碼。
5. **後端驗證**：我們的 Express 伺服器收到授權碼後，在後端向 Google 交換存取權杖 (Access Token)。
6. **建立 Session**：伺服器為該使用者建立一個 Session，並將使用者資訊存入其中，同時向瀏覽器發送一個加密的 Session Cookie。
7. **重導向至首頁**：伺服器將使用者導回網站首頁。前端偵測到登入狀態，更新 UI，顯示使用者名稱與頭像。

#### 自我檢核：登入流程

**🔰 基礎理解**（看懂流程）
- 如果 Google 回傳的授權碼無效，流程會停在哪一層？

**🌟 進階思考**（理解原理）
- 為什麼我們不能相信瀏覽器直接傳來的授權碼，而要在後端再驗證一次？
- 介面或日誌會出現哪些訊號，幫助你辨識登入失敗的原因？

**🌟🌟 應用能力**（遷移到新場景）
- 若要改成 GitHub OAuth，哪些設定可以沿用、哪些必須重新建立？

#### 💡 現實應用故事

**場景 1：社群媒體「以 GitHub 登入」**
GitHub 登入的流程與 Google OAuth 完全相同。當開發者登入 Vercel、Figma 或 GitLab 時，背後使用的都是同一套 OAuth 邏輯：
1. 使用者點「以 GitHub 登入」
2. 重導向至 GitHub 授權頁面
3. 使用者授權後，GitHub 回傳授權碼
4. 後端向 GitHub 交換 Access Token
5. 建立 Session，發送 Cookie

**場景 2：購物平台「使用 Facebook 登入」**
許多電商會提供「以 Facebook 登入」的選項，運作邏輯完全相同。只是把 Google 換成 Facebook，其他流程不變。

**場景 3：內部系統「與公司 AD 整合」**
企業系統通常會與 Active Directory 整合。後端要做的事還是一樣：從企業的身份驗證中心取得驗證碼 → 交換權杖 → 建立 Session。

**關鍵應用點：**
- **OAuth 的核心價值**：你不需要儲存使用者密碼，而是信任第三方的身份驗證。
- **可遷移的邏輯**：今天學會 Google OAuth，改成 GitHub、Facebook 或企業 AD 時，架構思維完全可以沿用，只需要換一些 API 端點。
- **後端的角色**：無論第三方是誰，後端始終要再驗證一次，這是安全設計的關鍵。

---

### 流程二：建立訂單與前往支付

#### 情境提要

顧客決定購買後，我們會先將這次的交易輸入資料庫，因為我們不確定付款過程會不會出現錯誤、顧客可能拿出錢包時發現身上錢不夠，以及我們也需要讓付款結果與我們的資料庫是可以對應的（可追溯）。

在這個過程中，我們會確認顧客身份等驗證都沒問題後，在資料庫建立一筆正式訂單，並將所有內容加密交予顧客，並引導他去金流平台頁面進行付款。

#### 流程圖

```
1. 已登入使用者點擊立即購買
   ↓
2. 前端 POST 請求至後端 /api/create-order
   ↓
3. 後端驗證 Session 和 CSRF Token
   ↓
4. 查詢商品資料
   ↓
5. 產生訂單資料和 MerchantOrderNo
   ↓
6. 加密訂單資料（TradeInfo 和 TradeSha）
   ↓
7. 回傳 Payuni 支付所需資訊給前端
   ↓
8. 前端自動提交表單至 Payuni 支付頁面
```

#### 4 個執行階段

1. **觸發**：已登入的使用者在 `index.html` 上點擊「立即購買」。

2. **前端請求**：前端 JavaScript 向後端的 `/api/create-order` 端點發起一個 `POST` 請求，請求中包含商品 ID 與 CSRF Token。

3. **後端處理**：
   - 伺服器驗證使用者的 Session 與 CSRF Token，確保請求合法。
   - 根據商品 ID 查找價格與商品名稱。
   - 產生一筆新的訂單資料，包含唯一的訂單號 (`MerchantOrderNo`)。
   - 將訂單資料與 Payuni 的 `HashKey` 及 `HashIV` 進行加密，產生 `TradeInfo`（加密後的訂單）與 `TradeSha`（簽名）。

4. **回傳給前端**：後端將 `TradeInfo`、`TradeSha` 及 Payuni 的 API 端點等必要資訊回傳給前端。

5. **跳轉至 Payuni**：前端收到後端的回應後，會動態建立一個表單，並自動將這些資訊 `POST` 到 Payuni 的支付頁面。此時，使用者的瀏覽器畫面會從您的網站跳轉到 Payuni 的網站。

#### 自我檢核：建立訂單流程

**🔰 基礎理解**（看懂流程）
- 建立訂單時，為什麼要用 CSRF Token？

**🌟 進階思考**（理解原理）
- 如果前端漏附 CSRF Token，後端如何偵測並拒絕？
- 當 Payuni API 規格更新時，哪些檔案和環境變數需要同步檢查？

**🌟🌟 應用能力**（遷移到新場景）
- 在什麼情境下你需要重新產生 `MerchantOrderNo`？
- 如果要改用不同的支付服務，這個流程中哪些地方需要改？

#### 💡 現實應用故事

**場景 1：Stripe 或 Apple Pay**
如果改用 Stripe 或 Apple Pay，這個流程的結構完全不變：
1. 產生訂單號（MerchantOrderNo）
2. 產生加密的訂單資料（Stripe 稱它為 `client_secret`，Apple Pay 稱為 `payment token`）
3. 回傳給前端，讓前端提交到支付服務

**場景 2：訂閱制系統（如 SaaS 軟體）**
許多 SaaS 軟體（Notion、Figma）使用訂閱制。客戶升級方案時，背後也是：
1. 建立一筆訂單
2. 使用 CSRF Token 防止誤操作
3. 加密訂單資料
4. 跳轉至支付服務

**場景 3：實體商店的 POS 系統**
便利商店收銀台掃條碼結帳時，背後也是類似的流程：
1. 產生訂單（收據號碼）
2. CSRF Token 的邏輯類似於「要求店員確認」
3. 加密（簽名）確保收據內容未被篡改
4. 將訂單送到收銀系統

**關鍵應用點：**
- **訂單設計的通用性**：無論是線上、線下、訂閱或一次性購買，「產生訂單 → 驗證 → 加密 → 送出」的邏輯都適用。
- **CSRF Token 的廣泛用途**：不只用於支付，任何「改變狀態」的重要操作（刪除帳號、修改設定、發佈內容）都應該用 CSRF 保護。
- **加密簽名的意義**：不只是金流，任何涉及「數據完整性」的地方（如配置檔、API 回應）都應該有簽名機制。

---

### 🚀 難度升級提示

讀到這裡，你已經理解了「使用者登入」和「建立訂單」這兩個相對直線性的流程。接下來的「Webhook 流程」會更複雜，因為涉及**異步通訊、兩條平行路線、加密驗證**等多個層面。

**建議在讀流程三前，回頭快速複習一下設計理念的「挑戰 3：支付成功的確定性」，這會幫你理解「為什麼需要這樣設計」，再來看技術細節就會清楚許多。**

---

### 流程三：支付確認與訂單紀錄 (Webhook)

#### 情境提要

在顧客付款成功後，金流平台會將結果通知我們和顧客：

**Return URL**：付款成功後，顧客會被告知已經付款了，形式可以由我們決定，可能是一張紙、可能只是一個訊息。
- **不可盡信**：它只是一個快速的操作回饋、非正式的通知。

**Notify URL (Webhook)**：幾乎在同一時間，金流平台會透過這個管道，將交易內容加密、送到我們處理專門 Notify 的地方。
- **唯一可信**：我們收到後，會解密內容並驗證是否有效。只有這則通知內容確認無誤，我們才會同步紀錄到會員的購買資料。

這是整個流程中相當關鍵的一步，它確保了交易的最終一致性。

#### 流程圖

```
1. 使用者在 Payuni 頁面完成支付
   ↓
2. Payuni 兵分兩路通知
   ├─ 路線 A：前端重導向至 result.html（快速回饋）
   └─ 路線 B：後端 Webhook 通知（真正確認）
   ↓
3. 路線 A 顯示結果給使用者（不代表成功）
   ↓
4. 路線 B：後端接收 Webhook
   ↓
5. 後端解密並驗證 Webhook 內容 Hash
   ↓
6. 🆕 主動向 Payuni API 查詢訂單（二次確認）
   ├─ 驗證金額是否相符
   ├─ 檢查訂單狀態
   └─ 取得完整訂單資訊
   ↓
7. 使用 API 查詢結果作為主要資訊源
   ↓
8. 整理訂單資料
   ↓
9. POST 請求至資料庫更新
   ↓
10. 訂單紀錄完成
```

#### 12 個執行步驟（含二次確認）

##### 前置與初始驗證（1-5）

1. **使用者支付**：使用者在 Payuni 頁面輸入信用卡資訊並完成支付。

2. **兵分兩路**：
   - **路徑 A (前端)**：Payuni 將使用者的瀏覽器導回到您指定的 `PAYUNI_RETURN_URL` (`result.html`)。**這僅用於提供即時的使用者體驗，不應作為訂單成功的依據。**
   - **路徑 B (後端 - 真實的交易通知)**：在背景，Payuni 的伺服器會向您在 `.env` 中設定的 `NOTIFY_URL` (`/payuni-webhook`) 發送一個 `POST` 請求。這就是「Webhook」，是唯一可信的交易結果通知。

3. **後端接收 Webhook**：您的 Express 伺服器接收到這個 Webhook 請求，內含加密的 `EncryptInfo` 和簽名 `HashInfo`。

4. **驗證 Hash 簽名**：使用 SHA-256 演算法驗證 Webhook 的完整性，確保內容未被竄改。驗證失敗直接返回 "FAIL"。

5. **解密 Webhook 資料**：使用 `PayuniSDK.js` 中的 AES-256-GCM 解密函式，將加密的 `EncryptInfo` 解密，提取訂單編號（MerTradeNo）和初步的支付資訊。

##### 二次確認 - API 主動查詢（6-9）🆕

6. **主動查詢 Payuni Query API**：
   - 為了防止 Webhook 被駭客中間人攻擊或偽造，後端主動向 Payuni 查詢 API 發起查詢請求
   - 傳入訂單編號（MerTradeNo）和時間戳，使用相同的加密機制
   - 這是「第二個獨立的數據來源」，與 Webhook 無關

7. **驗證 API 回應簽名**：查詢結果同樣包含 Hash，需驗證其真實性。

8. **金額欺詐檢查**：比較 Webhook 中的金額 vs 官方 API 查詢結果的金額。
   - 如果不符 → 記錄詐欺警告，返回 "FAIL"
   - 如果相符 → 繼續處理

9. **確定資料來源**：
   - **使用 API 查詢結果作為主要資訊來源**（而非 Webhook）
   - API 代表 Payuni 官方狀態，不會被前端或 Webhook 層級的攻擊影響
   - 標記此訂單為 `queryVerified: true`，追蹤驗證狀態

##### 資料庫寫入（10-12）

10. **整理訂單資料**：將驗證後的 API 查詢結果、使用者資訊、商品資訊整合為統一格式，準備寫入資料庫。

11. **寫入資料庫**：透過資料庫抽象層（Google Sheets API 或其他），將訂單記錄寫入持久化儲存。
    - 記錄欄位包含：訂單編號、交易序號、支付狀態、金額、驗證標記、時戳

12. **完成確認**：
    - 返回 "OK" 告知 Payuni 此 Webhook 已成功處理
    - Payuni 停止重試此筆通知
    - 後端可進行後續動作：發送確認郵件、更新庫存、通知系統管理員等

#### 自我檢核：Webhook 流程

**🔰 基礎理解**（看懂流程）
- 為什麼需要兩條通知路線（Return URL 和 Notify URL）？
- 為什麼即使 Webhook 解密成功，我們還要再查一次 API？

**🌟 進階思考**（理解原理）
- 如果 Payuni Webhook 遲遲未到，你還能從哪裡追蹤交易狀態？
- 金額不符（Webhook ≠ API）表示什麼？應該如何處理？
- 為什麼使用 API 查詢結果作為主要資訊，而不是 Webhook？

**🌟🌟 應用能力**（遷移到新場景）
- 如果要改用資料庫而非 Google Sheet，哪些節點需要替換？
- 除了金額檢查，可能還有什麼欄位被二次確認？
- 如果訂單狀態是「未付款」但已通過驗證寫入資料庫，代表什麼？該如何追蹤？

**🔒 安全思維**（防止攻擊）
- 如果駭客偽造 Webhook，系統怎麼防？（Hash 驗證 + API 查詢）
- 如果 API 查詢也被中間人攻擊，怎麼辦？（密鑰管理、HTTPS）
- 重複提交同一筆訂單會怎樣？系統怎麼預防？（記錄 queryVerified 標記）

#### 💡 現實應用故事

**場景 1：電商平台（如蝦皮、Momo）**
當你在蝦皮買東西，跳轉到信用卡支付後：
- **Return URL**：支付完成立即看到「已收款」訊息（使用者體驗）
- **Webhook**：背景同時向官方查詢 API 確認訂單真實狀態
- **二次確認機制**：防止黑客竄改 Webhook 資訊來偽造訂單
- **金額檢查**：確保消費者只被扣款一次，不被重複刷卡
- **資料寫入**：訂單寫入訂單系統、觸發倉庫揀貨、發送出貨通知

**場景 2：SaaS 服務升級（如 AWS、GitHub Copilot）**
當你升級訂閱方案時：
- **Return URL**：立即看到「升級成功」的頁面
- **Webhook**：背景同時查詢官方系統確認新配額
- **二次確認**：防止某人透過偽造 Webhook 升級到高級方案卻只付基礎金額
- **資料同步**：更新帳戶配額、產生新發票、發送確認郵件

**場景 3：金融交易（銀行轉帳、股票交易）**
當你進行股票買賣時：
- **即時反饋**：交易頁面顯示「已送出」
- **Webhook + API 查詢**：銀行系統既接收交易通知，也主動查詢清算系統
- **多層驗證**：防止金額竄改導致重大財務損失
- **審計追蹤**：所有驗證步驟都記錄在案，便於後續查核
- **Return URL**：立即回傳「收到包裹」訊息給掃描設備
- **Webhook**：背景同時更新物流系統、發送顧客通知、觸發倉庫入庫流程

**場景 4：郵件服務（如 SendGrid、Mailgun）**
當你用服務發送大量郵件時：
- **Return URL**：立即回傳「郵件已排隊」
- **Webhook**：背景陸續接收「已送達」、「已開啟」、「點擊連結」等事件，更新分析數據

**關鍵應用點：**
- **分離關注**：「使用者體驗」（Return URL）和「系統確認」（Webhook）要分開
- **非同步設計**：Webhook 無需立即完成，允許有一定延遲，讓系統更穩定
- **重試機制**：Webhook 失敗時應該有重試機制，確保最終一致性
- **可擴展性**：無論訂單量多大，Webhook 架構都能應對，因為它是非同步的

**延伸思考：**
如果改用 MongoDB 而非 Google Sheet，你只需要把「步驟 8」改成「將 JSON 寫入 MongoDB」，整個 Webhook 流程不用改，因為架構已經充分解耦。

---

## 3️⃣ 結論：為什麼每一道防線都重要

你可以注意到，我們的所有流程都相當強調「驗證有效性」這點。

不論是透過：
- Google 登入來驗證使用者是否正常
- 將所有敏感資訊加密
- 使資料可追溯
- 使用 CSRF Token 等各種機制來防止偽造請求
- 完全由後端進行最終支付資料的加密/解密與驗證來確保支付的有效性

**每一道防線都是為了確保：**

1. **使用者身份真實**：只有真正的使用者才能存取系統。
2. **請求合法有效**：盡可能所有操作都來自可信來源，增加惡意使用者的成本與門檻。
3. **資料完整未篡改**：任何傳輸中的資料都經過加密與簽名驗證。
4. **交易結果可追溯**：確保訂單紀錄與金流方平台一致。

> **核心啟示：** 當你在客製化或擴充功能時，**永遠要記住保護這些驗證環節的重要性**。不要跳過任何簽名檢查、Session 驗證或加密步驟，因為這些看似「麻煩」的機制，才是保護你和你用戶資料安全的關鍵。

---

## 4️⃣ 設計啟示：可轉移技能

讀完這份系統架構，你不只學會了「金流怎麼串」，更重要的是學會了以下可以應用在任何專案的設計原則：

### 0. PayuniSDK：加密與驗證的統一接口 🆕

**背景**：系統中有許多涉及 Payuni 的操作—生成加密支付資訊、驗證 Webhook、查詢訂單狀態。如果每次都直接呼叫底層的加密/解密函式，程式碼會散亂且容易出錯。

**解決方案**：建立 `PayuniSDK` 類別，統一封裝所有與 Payuni 互動的邏輯。

**SDK 包含的核心方法：**

| 方法 | 用途 | 調用時機 |
|------|------|--------|
| `generatePaymentInfo(...)` | 生成加密的支付資訊 | 使用者建立訂單時 |
| `verifyWebhookData(encryptInfo, hashInfo)` | 驗證 Webhook 簽名 | Payuni 伺服器發送通知時 |
| `parseWebhookData(encryptInfo)` | 解密 Webhook 資料 | 確認簽名有效後 |
| `queryTradeStatus(merTradeNo)` | 🆕 主動查詢訂單狀態 | Webhook 接收後（二次確認） |
| `validateAndParseWebhook(...)` | 綜合驗證和解密 | 簡化常見的驗證流程 |

**使用 SDK 的好處：**
- ✅ **單一責任**：加密邏輯集中管理，減少出錯機會
- ✅ **易於測試**：所有加密操作都在一個地方，便於單元測試
- ✅ **程式碼清晰**：調用端不需要理解加密細節，只需呼叫高層方法
- ✅ **安全可控**：金鑰、IV、雜湊密鑰等敏感資訊都在 SDK 內部管理
- ✅ **便於擴展**：新增支付功能時，只需在 SDK 中添加新方法

**實際例子**：

```javascript
// 建立訂單時—生成支付連結
const sdk = getPayuniSDK();
const paymentInfo = sdk.generatePaymentInfo(
  tradeNo, 
  product, 
  email, 
  returnUrl
);
// 返回：{ payUrl, data: { MerID, Version, EncryptInfo, HashInfo } }

// Webhook 接收時—二步驗證
const webhookVerified = sdk.verifyWebhookData(encryptInfo, hashInfo);
if (!webhookVerified) return res.send("FAIL");

const decrypted = sdk.parseWebhookData(encryptInfo);
const tradeNo = decrypted.MerTradeNo;

// 🆕 主動查詢確認
const queryResult = await sdk.queryTradeStatus(tradeNo);
if (!queryResult.success) return res.send("FAIL");

// 金額檢查（詐欺防護）
if (queryResult.data.amount !== decrypted.TradeAmt) {
  logger.error("❌ 金額不符，可能詐欺");
  return res.send("FAIL");
}
```

**進階理解**：這是「策略模式」的應用—將複雜的 Payuni 交互策略封裝為一個高內聚的物件，使用端不需要知道內部細節。

---

### 1. 多層驗證的思維

**在金流案例中的體現：**
- Google OAuth 驗證使用者身份
- Session Cookie 維持登入狀態
- CSRF Token 防止跨站攻擊
- Webhook 簽名驗證支付結果
- 🆕 API 查詢二次確認訂單狀態
- 🆕 金額檢查防止詐欺

**可應用的場景：**
- 會員系統：登入 + 二次驗證 + 操作確認
- 訂單系統：身份驗證 + 庫存檢查 + 支付確認
- 內容管理：權限驗證 + 操作日誌 + 審核機制

**核心啟示：** 永遠不要假設「前一步驗證過了，這一步就安全」。每一層都要獨立驗證。

### 2. 關注點分離的架構

**在金流案例中的體現：**
- 前端：只負責 UI 展示和使用者互動
- 後端：處理業務邏輯、驗證和資料處理
- Payuni：專注處理支付流程
- Google Sheets/GAS：單純儲存訂單資料
- 🆕 PayuniSDK：統一封裝加密、解密、驗證邏輯

**可應用的場景：**
- 社群登入整合（OAuth 提供者 + 你的系統 + 資料庫）
- 第三方 API 串接（外部服務 + 中間層 + 你的業務邏輯）
- 微服務架構（各服務獨立部署、各司其職）

**核心啟示：** 當每個部分只做一件事且做好時，系統更容易理解、測試和維護。

### 3. 非同步通訊的處理

**在金流案例中的體現：**
- **Return URL**：使用者支付完成後的「即時回饋」（前端體驗）
- **Notify URL (Webhook)**：Payuni 伺服器的「非同步通知」（真實交易結果）
- 🆕 **Query API**：後端主動查詢官方狀態（二次確認機制）

**可應用的場景：**
- 發送郵件（觸發後背景處理，不阻塞使用者）
- 產生報表（運算時間長，用 Webhook 通知完成）
- 批次處理（大量資料處理，進度通知）
- 第三方服務整合（等待外部回應）

**核心啟示：** 區分「使用者需要立即看到的回饋」和「真正完成的確認」，設計更可靠的系統。不要只相信單一通道，要透過多個獨立來源進行確認。

### 4. 安全優先的設計原則

**在金流案例中的體現：**
- 所有敏感資訊都加密傳輸（AES-256-GCM）
- 所有 API 金鑰都存在 `.env` 而非程式碼中
- 永遠不經手信用卡資訊（委託給 Payuni）
- 使用 `httpOnly` Cookie 防止 XSS 竊取 Session
- 🆕 Webhook 簽名驗證防止偽造
- 🆕 API 查詢二次確認防止中間人攻擊
- 🆕 金額檢查防止重複扣款或詐欺

**可應用的場景：**
- 健康醫療資料（加密儲存、傳輸、存取控制）
- 財務資訊（最小權限、審計日誌、多重驗證）
- 個人隱私（資料去識別化、同意管理）

**核心啟示：** 「安全」不是功能做完後才加上去的，而是從設計之初就要內建的。防守深度（Defense in Depth）的概念很重要—每一層都有防線，即使一層被突破，還有其他層保護。

---

## 📚 下一步

| 如果你想... | 推薦閱讀 |
|-----------|--------|
| **深入了解安全防護機制** | `安全機制` |
| **自己客製化這套方案** | `動手實踐` |
| **部署到線上環境** | 內部文件 `04_DEPLOYMENT.md` |
| **遇到問題找答案** | 內部文件 `07_TROUBLESHOOTING.md` |

---

## 📌 本章學到的能力

讀完本章，你應該能做到以下事項。如果某項還不確定，建議回頭複習對應段落。

| 你練習到的能力 | 檢核方式 | 進階應用 |
|-------------|--------|--------|
| **系統拆解** | 能畫出「前端→後端→第三方→資料庫」的資料流 | 把這套模型套到你自己的專案上 |
| **信任邊界判斷** | 能說清楚「為什麼前端不能信」、「為什麼後端要再驗一次」 | 在設計新 API 時，清楚地標出「信任邊界」 |
| **非同步設計思維** | 理解「Return URL vs Webhook」的差異，知道何時該用哪個 | 在下一個非同步任務中應用 |
| **防線設計** | 能指出每個流程中「驗證、加密、防偽造」在哪裡發生 | 為新功能補上適當的防線 |

---

*定位補述：這份架構解說已依據策略文件重寫，請在擴充或補充內容前先對照該報告，確保每個細節仍在「能力導向、教學優先」的框架下。*
