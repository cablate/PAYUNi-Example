# 系統架構：駭客會攻擊哪裡？

> **這是一張「戰場地圖」。**
> 我們標出了 6 個核心元件和 3 條關鍵流程，以及駭客最喜歡攻擊的「信任邊界」。

---

## 👔 給決策者的 30 秒懶人包

**如果您是老闆或 PM，請只讀這一段：**

1.  **為什麼要看這張圖？** 因為這張圖定義了「誰該負責什麼」。如果之後出事，這張圖能幫你快速釐清是「前端顯示錯了」還是「後端算錯了」。
2.  **這套系統最核心的觀念是什麼？** 是「不信任」。我們假設使用者的電腦已經被駭客控制了，所以所有跟錢有關的計算，都必須在我們自己的伺服器（後端）重算一次。
3.  **關鍵字翻譯**：
    *   **前端 (Frontend)** = 櫃台人員（只負責收單，沒權限改價格）。
    *   **後端 (Backend)** = 金庫管理員（負責核對金額，有權限拒絕交易）。
    *   **Webhook** = 銀行寄來的入帳通知信（我們只信這個）。

---

## 📖 這一頁是什麼

這一章是你進入「實戰」前的最後一次簡報。我們不講空泛的理論，我們講**「邊界」**。
你知道為什麼大多數金流系統會被駭嗎？因為開發者搞不清楚**「誰可以信，誰不能信」**。

**預期耗時：** 15 分鐘
**你將學到：** 信任邊界、責任分工、以及「如果這層破了會怎樣」。

---

## 1️⃣ 核心元件與「信任邊界」

這張表不是給你背的，是給你看清楚**風險在哪裡**，以及**程式碼在哪裡**。

| 元件 | 角色 | 信任等級 | 💀 如果你信了它會怎樣 (Risk) | 📂 對應程式碼 (Code) |
|------|------|---------|------------|-------------------|
| **前端** | 介面 | **❌ 零信任** | **使用者可以隨便改前端 Code**。如果你在前端算錢，駭客會直接用 $1 元買走你的 $1000 元商品。 | `src/public/js/app.js` |
| **後端** | 守門員 | **✅ 可信 (你的地盤)** | **這是你的最後防線**。如果後端沒驗證，所有從前端來的髒資料都會直接汙染資料庫。 | `src/routes/api.js` |
| **Payuni** | 金主 | **✅ 可信 (外部)** | **金流方只管收錢**。他們不會管你的庫存夠不夠，也不會管這筆訂單是不是重複刷的。 | `src/services/payment/PayuniSDK.js` |
| **資料庫** | 倉庫 | **✅ 可信 (內部)** | **資料庫只是倉庫**。不要期待倉庫管理員幫你抓小偷，那是保全（後端）的事。 | `src/data/products.js` (模擬) |

> **🛡️ 核心戰術：**
> 畫一條紅線把「前端」和「後端」隔開。這條線叫**信任邊界**。
> 線左邊（前端）傳過來的所有東西，都要視為**有毒的**，必須經過清洗（驗證）才能放進線右邊。

---

## 2️⃣ 三大核心流程（與攻擊點）

### 流程一：使用者登入 (Google OAuth 2.0)

**情境**：我們要確認這個人是誰，而且不能讓他偽造身份。

#### 🚨 駭客攻擊點
- **偽造 Token**：如果後端不跟 Google 二次確認，駭客可以用隨便生成的字串騙過登入。
- **竊取 Session**：如果 Cookie 沒設 `HttpOnly`，駭客可以用 XSS 偷走使用者的登入狀態。

#### ✅ 我們的防禦流程
```
1. 使用者點擊「使用 Google 登入」
   ↓
2. Google 回傳授權碼 (Authorization Code)
   ↓
3. 🛑 [防線] 後端拿授權碼去跟 Google 換 Token (確保是 Google 發的)
   👉 程式碼：src/services/auth/GoogleAuthService.js
   ↓
4. 🛑 [防線] 建立 Session，發送 HttpOnly Cookie (確保前端偷不走)
   👉 程式碼：src/middleware/session.js
```

---

### 流程二：建立訂單 (付錢之前)

**情境**：使用者說「我要買這個」，我們準備收錢。

#### 🚨 駭客攻擊點
- **竄改金額**：前端傳 `price: 1` 給後端。
- **CSRF 攻擊**：駭客做一個假按鈕，騙已登入的使用者點擊，幫駭客買東西。

#### ✅ 我們的防禦流程
```
1. 前端發送「我要買商品 ID: 001」 (不傳金額！)
   ↓
2. 🛑 [防線] 後端檢查 CSRF Token (確保是本人點擊)
   👉 程式碼：src/middleware/security.js (csurf)
   ↓
3. 🛑 [防線] 後端去資料庫查 ID: 001 的價格 (確保金額正確)
   👉 程式碼：src/services/order/OrderService.js
   ↓
4. 🛑 [防線] 後端用 AES-256 加密訂單資料 (確保傳輸過程不被改)
   👉 程式碼：src/utils/crypto.js
   ↓
5. 產生加密字串，丟給前端去跳轉 Payuni
```

---

### 流程三：Webhook 確認 (付錢之後)

**情境**：Payuni 告訴我們「收到錢了」。

#### 🚨 駭客攻擊點 (最危險！)
- **偽造 Webhook**：駭客自己發一個 POST 請求到你的 Webhook URL，說「我付錢囉」。
- **重播攻擊**：駭客把昨天的成功通知再發一次，讓你重複出貨。

#### ✅ 我們的防禦流程
```
1. Payuni 發送 Webhook 通知
   ↓
2. 🛑 [防線] 後端驗證 Hash 簽名 (確保是 Payuni 發的)
   👉 程式碼：src/routes/webhook.js
   ↓
3. 🛑 [防線] 後端主動 Call Payuni API 查詢訂單 (二次確認，防止偽造)
   👉 程式碼：src/services/payment/PayuniSDK.js
   ↓
4. 🛑 [防線] 檢查金額是否與訂單相符 (防止付 1 元買 1000 元商品)
   ↓
5. 寫入資料庫，標記「已付款」
```

---

## 3️⃣ 設計啟示：PayuniSDK 的戰略意義

你可能會問：「為什麼要寫一個 `PayuniSDK.js`？直接寫在 Controller 不行嗎？」

**不行。** 因為分散的邏輯 = 漏洞。

我們把所有跟錢有關的邏輯（加密、解密、驗證、查詢）全部封裝在 `PayuniSDK` 裡。這就像把公司的金庫鑰匙只交給一個人保管。

**SDK 幫你擋了什麼？**
- **加密細節**：AES-256-GCM 的 IV 和 Key 管理，寫錯一個參數就解不開。
- **驗簽邏輯**：自動檢查 Payuni 傳來的 Hash，忘記檢查就等著被駭。
- **統一接口**：不管你是要建立訂單還是查訂單，都透過 SDK，確保標準一致。

---

## 📚 下一步

現在你有了地圖，知道哪裡危險了。
下一步，我們要去檢查裝備，確保你的盾牌（安全設定）都裝好了。

👉 **[前往安全機制：怎麼設定才不會背鍋？](/03_security-deep-dive)**

---

## ✅ 戰場生存檢查 (Flight Check)

讀完這章，請確認你能回答這三個問題：

1.  **為什麼前端傳來的 `price` 絕對不能信？**
2.  **為什麼 Webhook 收到後，還要主動去查一次 API？**
3.  **如果駭客偷走了使用者的 Session Cookie，他能做什麼？我們怎麼防？**

(答不出來？回去重讀流程圖，不然上線就是送頭。)
