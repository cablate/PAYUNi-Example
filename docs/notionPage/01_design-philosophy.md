# 設計理念：為什麼大多數金流系統會失敗？

> **別等出事了才學會這些。**
> 這裡有 4 個真實世界的「慘案」，以及我們如何用設計原則來避免它們。

---

## 🧭 本章定位：Stage 1 / Understand Why

- **你現在的位置**：剛看完 `index.md`，準備進入「防雷區」。
- **本章目標**：把抽象的設計原則，變成你跟資安團隊、老闆吵架時的底氣。
- **輸出物**：一份「慘案預防對照表」，讓你知道每一行 code 是在擋什麼災。

### 閱讀前先確認
- 你不需要現在就懂程式碼細節。
- 你需要帶著「如果我不這樣做，會發生什麼事？」的心態來讀。

---

## 🎯 四大挑戰（與真實慘案）

### 挑戰 1：「我怎麼確保顧客的資料安全？」

> **💀 真實慘案：**
> 某個開發者為了方便 debug，把 API Key 寫死在前端 JavaScript 裡。駭客按了一下 F12，拿走了 Key，然後用他們的帳戶刷了 500 筆退款，直接讓公司損失 30 萬。

當顧客在你的網站上支付時，他們信任你會妥善保護他們的資訊。但現實是：

- **信用卡資訊可能被竊取**：如果你的伺服器被駭客入侵，會損失多少？
- **API Key 洩露的代價很大**：如果金流 API 金鑰被公開，駭客能直接操作你的帳戶。
- **偽造的請求可能騙過你**：如何確認一個 Webhook 真的來自 Payuni，而不是駭客偽造的？

#### ✅ 我們的解法：多層驗證與安全優先思維

我們採取「防禦深度」策略，就像洋蔥一樣，剝了一層還有一層：
- **永遠不經手信用卡**：委託給 Payuni（PCI-DSS 合規），我們只存 Token。
- **所有敏感操作都加密傳輸**：AES-256-GCM，讓駭客攔截了也只看到亂碼。
- **每個請求都驗證**：Session、CSRF Token、Webhook 簽名，缺一不可。
- **敏感資訊隔離管理**：`.env` 與程式碼分離，絕對不進 Git。

---

### 挑戰 2：「系統怎樣設計才不會變成一團亂？」

> **💀 真實慘案：**
> 某個團隊把「計算金額」的邏輯寫在前端，後端直接接收前端傳來的 `amount`。結果一個大學生把 HTML 裡的 `value="1000"` 改成 `value="1"`，然後用 1 元買走了旗艦手機。

隨著功能增加，程式碼變得複雜：
- **前端、後端、支付系統都要互動**：如果改動一個地方，其他地方會不會壞？
- **一個元件出問題，其他元件要不要跟著受影響？**

#### ✅ 我們的解法：關注點分離（Separation of Concerns）

我們把系統拆成獨立的角色，每個只做自己該做的事，**並且互不信任**：
- **前端**：只負責「畫畫面」。**它的任何資料都不可信**。
- **後端**：負責「算錢」和「驗證」。它是守門員。
- **Payuni**：只負責「收錢」。
- **資料庫**：只負責「存結果」。

**核心原則：** 永遠假設前端已經被駭客控制了。後端必須重新計算所有金額。

---

### 挑戰 3：「支付成功了，我怎麼才能確定？」

> **💀 真實慘案：**
> 某個網站只靠「前端跳轉頁面」來判斷付款成功。結果駭客發現只要直接輸入 `https://site.com/success`，系統就會以為他付錢了，自動發貨。

最複雜的一個問題：
- **使用者點完按鈕後，可能網路中斷**：我還是收到錢嗎？
- **Payuni 可能成功處理，但通知卻遲到**：要不要重複計費？

#### ✅ 我們的解法：非同步通訊與最終一致性

我們設計了兩條平行的通知路線，**缺一不可**：
1.  **即時回饋 (Return URL)**：告訴使用者「看起來成功了」（這是給人看的，不準）。
2.  **可信通知 (Webhook)**：後端驗證「確實成功了」，然後才更新資料庫（這是給系統看的，才準）。

這樣即使其中一條路出問題，另一條路仍能確保系統的一致性。

---

### 挑戰 4：「我怎麼知道系統哪裡出問題了？」

> **💀 真實慘案：**
> 客服接到電話：「我付錢了但沒收到東西！」工程師查了半天，發現 Log 只有一行 `Error: failed`。完全不知道是 Payuni 掛了、還是資料庫掛了、還是 Webhook 簽名錯了。

當某個顧客說「我付了錢但沒收到商品」，你要怎麼查？

#### ✅ 我們的解法：可觀測性（Observability）

我們在設計時確保：
- **每個請求都有唯一的追蹤 ID**。
- **每個重要操作都有日誌記錄**（Log everything）。
- **文件清楚說明各流程的預期行為**。

這樣當問題發生時，你能從日誌追蹤整個交易的生命週期，而不是瞎猜。

---

## 📊 慘案預防對照表

讀到這裡，請把這張表印在腦子裡：

| 潛在慘案 | 我們的防禦機制 | 為什麼有效 |
|---------|--------|---------|
| **API Key 外洩被盜刷** | `.env` 隔離 + 後端代理 | Key 永遠不出現在前端程式碼中 |
| **1 元買手機 (竄改金額)** | 後端重算金額 | 不信任前端傳來的任何數字 |
| **直接訪問 /success 騙貨** | Webhook 驗簽 + 雙重確認 | 只相信經過加密簽名的後端通知 |
| **訂單消失無影無蹤** | 完整 Log + 追蹤 ID | 凡走過必留下痕跡，死也要死得明白 |

---

## ⚡ 快速開始：把理念化成行動

### Step 1：定位你的恐懼（5 分鐘）
問自己：
- 我最怕發生哪種慘案？（被駭、賠錢、還是被老闆罵？）
- 這個專案裡，哪一層防護最容易被忽略？

### Step 2：親眼看看系統架構（5 分鐘）
打開 `index.js` 和 `docs/` 資料夾，掃一眼：
- 看看 `config` 資料夾，確認 `.env` 是怎麼被載入的。
- 看看 `routes`，確認所有金流邏輯都在後端。

### Step 3：帶著問題進入下一章（5 分鐘）
當你讀 `系統架構` 時，心裡帶著這些問題：
1.  **這個流程的每一步，駭客會想怎麼鑽空子？**
2.  **如果 Payuni 突然掛了，我的系統會怎樣？**

---

## 📌 下一步

你現在知道「為什麼」要這樣設計了（為了保命）。
下一步，讓我們看看這座堡壘的「地圖」。

👉 **[前往系統架構：駭客會攻擊哪裡？](/02_system-architecture)**

---

## 🚨 漏風流程 vs 🔐 修復流程（Stage 1 → Stage 2 的橋接）

### ❌ 漏風流程（新手最愛寫的 Code）
```text
1. 前端直接傳 `price: 100` 給後端                    ← 駭客改成 1 元
2. 後端沒驗證 Session 就建立訂單                     ← 駭客用機器人灌爆資料庫
3. Webhook 收到後直接信了                           ← 駭客偽造 Webhook 請求
4. 資料庫顯示「已付款」                             ← 公司賠錢
```

### ✅ 修復流程（Battle-Tested 架構）
- **後端查價**：前端傳 ID，後端自己去查資料庫價格。
- **Session 驗證**：沒登入？沒 Token？直接擋在門外。
- **Webhook 驗簽**：簽名不對？直接丟棄。
- **API 二次確認**：Webhook 說成功還不夠，我們主動問 Payuni「真的嗎？」。

**Stage 1 結論：** 安全不是功能，是習慣。接下來的章節，我們會把這些習慣變成程式碼。
