# 安全機制：怎麼保護

> 5 層防禦深度設計 + 每層的技術原理 + 常見誤區

---

## 📖 這一頁是什麼

歡迎來到「金流整合實戰包」的安全性核心。線上交易的基礎是信任，而信任來自於強大的安全機制。

本文件將深入探討此專案中為您內建的各項安全機制，讓您不僅知道「如何使用」，更理解「為何如此設計」。

我們採用了「**深度防禦** (Defense in Depth)」策略，透過多層次的防護，即使某一層被繞過，其他層依然能保護您的應用程式與使用者資料。

**預期耗時：** 20 分鐘  
**你將學到：** 5 層防禦、每層的原理、應用場景、常見錯誤

---

## 🔒 五層防禦深度解析

我們按照「從外到內」的順序，為您講解五層防護：

---

### 第 1 層：Helmet - 您的第一道 HTTP 防線

#### 是什麼？

`Helmet` 是一個 Express 中介軟體，它本身是 15 個小型中介軟體的集合，專門用來設定與安全性相關的 HTTP 標頭 (HTTP Headers)。

#### 為什麼重要？

許多常見的 Web 攻擊，如跨站腳本攻擊 (XSS)、點擊劫持 (Clickjacking)，都可以透過正確設定 HTTP 標頭來防範。Helmet 為您自動處理了這些繁瑣但至關重要的設定。

#### 它具體做了什麼？

- **`Strict-Transport-Security`**：強制瀏覽器只能使用 HTTPS 與您的伺服器通訊，杜絕中間人攻擊。
- **`X-Content-Type-Options`**：防止瀏覽器「猜測」檔案類型，避免惡意檔案被當作可執行腳本。
- **`X-Frame-Options`**：防止您的網頁被嵌入到 `<iframe>` 中，防禦點擊劫持攻擊。
- **`Content-Security-Policy`**：(可選，但功能強大) 能精確定義允許載入哪些來源的腳本、樣式、圖片等，是防禦 XSS 的利器。

#### 簡單來說...

> **Helmet 就像是為您的網站聘請了一位全天候的保全，檢查所有進出的網路請求，確保它們符合安全規範。**

#### 在金流實戰包中的實例

每當使用者透過瀏覽器訪問您的網站時（無論是首次載入 `index.html`、完成 Google 登入後的重導向、或是顯示支付結果的 `result.html`），Helmet 都會自動在回應中附加這些安全標頭。例如：

- 當 Payuni 的支付頁面完成後，使用者被導回您的 `result.html` 時，Helmet 確保了即使該頁面被嵌入到惡意頁面的 `<iframe>` 中，瀏覽器也會拒絕執行。
- 所有 API 請求的回應都強制使用 HTTPS，防止通訊被中間人攔截。

#### 延伸思考：這個機制可以用在哪裡？

**適用場景：**
- 任何面向公眾的網站（部落格、企業官網、電商平台）
- 需要保護使用者免受 XSS 攻擊的應用
- 任何需要防止點擊劫持的頁面（如支付頁面、敏感操作頁面）

**關鍵啟示：** HTTP 標頭是「無形的防護牆」，使用者看不到，但它們時刻在保護著瀏覽器和伺服器之間的通訊安全。

#### ⚠️ 常見錯誤 / 誤解

- **只在本機啟用 HTTPS**：一旦上線卻仍允許 HTTP，就等於關掉 `Strict-Transport-Security` 的效益。
- **自訂 CSP 時全部改成 `*`**：放寬 `Content-Security-Policy` 會讓 XSS 防線瞬間崩潰，寧可逐一列出合法來源。
- **局部路由關閉 Helmet**：為了某個第三方 widget 關閉整組標頭，很容易遺漏重新開啟。

---

### 第 2 層：CORS - 精準控制 API 存取

#### 是什麼？

CORS 是一種瀏覽器安全機制，它限制了網頁只能請求與自己「同來源」(Same-Origin) 的資源。當您需要從 `your-domain.com` 的前端去請求 `api.your-domain.com` 的後端時，就需要 CORS 規則來「放行」。

#### 為什麼重要？

如果沒有正確設定，任何惡意網站都可以透過其前端 JavaScript，向您的後端 API 發起請求（例如，嘗試代表已登入的使用者下訂單）。

#### 它具體做了什麼？

在 `index.js` 中，我們使用 `cors` 中介軟體，並設定只允許來自您在 `.env` 檔案中指定的 `DOMAIN` 的請求。

#### 簡單來說...

> **CORS 像是機場的「登機口管制」，只有拿著正確航空公司登機證的乘客，才能進入該航空公司的登機口。在前後端分離的架構中，CORS 確保只有來自「合法前端網域」的請求才能存取您的後端資源。**

#### 在金流實戰包中的實例

在系統架構的三個流程中，前端都需要向後端 API 發起請求：

- 流程一：前端請求 `/auth/google/callback` 以完成登入
- 流程二：前端請求 `/api/create-order` 建立訂單
- 流程三：後端向 Payuni 的 Webhook 回應

CORS 設定確保了只有來自您在 `.env` 中指定的 `DOMAIN` 的請求才會被接受。舉例，如果 `DOMAIN=https://myshop.com`，那麼即使有人在 `https://malicious.com` 上寫的 JavaScript 試圖呼叫您的 API，瀏覽器也會基於 CORS 政策直接拒絕該請求。

#### 延伸思考：這個機制可以用在哪裡？

**適用場景：**
- **社群媒體前後端分離應用**：Instagram 的前端頁面只能呼叫 Instagram 自己的後端 API
- **企業內部管理系統**：公司的 HR 系統前端只能向公司內部 API 發送請求
- **線上課程平台**：學員觀看課程的網頁只能向該平台的伺服器請求影片資源

**關鍵啟示：** CORS 為你設定一個「邊界」，清楚地指定誰能和你溝通。

#### ⚠️ 常見錯誤 / 誤解

- **偷懶寫 `origin: '*'`**：金流或任何需要帶憑證的 API 避免用萬用字元。
- **忘記限制 HTTP 方法與 Headers**：預設放行所有方法，會讓惡意網站有機會嘗試 PUT/DELETE 等敏感操作。

---

### 第 3 層：CSRF - 保護使用者操作的真實性

#### 是什麼？

CSRF (Cross-Site Request Forgery) 是一種常見的攻擊。攻擊者在自己的網站上放置一個陷阱（例如，一張看不見的圖片或一個表單），誘騙已在您網站登入的使用者點擊。一旦點擊，使用者的瀏覽器就會在不知情的情況下，向您的伺服器發送一個惡意請求（例如，更改密碼、下訂單）。

#### 為什麼重要？

因為瀏覽器會自動帶著使用者的 Cookie（包括 Session），所以伺服器會以為這個請求是合法的使用者發起的，導致惡意操作成功。

#### 它具體做了什麼？

我們採用了 `csurf` (Token-Based CSRF 防護)：

1. 當使用者載入您的頁面時，伺服器會產生一個獨一無二、不可預測的 `CSRF Token`。
2. 前端在發起任何會改變狀態的請求（如 `POST` 請求去建立訂單）時，必須在請求中附上這個 Token。
3. 後端在收到請求時，會驗證這個 Token 是否匹配。如果 Token 不存在或不正確，請求將被拒絕。

#### 簡單來說...

> **CSRF Token 像是「手寫簽名」，每次重要操作都需要一個只有您和銀行知道的獨特簽名。即使駭客知道您的帳號密碼（Session），沒有這個即時產生的簽名，也無法代替您執行操作。**

#### 在金流實戰包中的實例

當使用者在系統架構的「流程二」點擊「立即購買」時，前端會：

1. 從伺服器取得最新的 CSRF Token（在頁面載入時）
2. 在 POST 至 `/api/create-order` 時，將此 Token 附在請求中
3. 後端驗證 Token 是否正確，只有通過驗證才會建立訂單

這確保了訂單一定是使用者親自在您的網站上點擊「購買」按鈕發起的，而不是被其他網站的陷阱誘騙。

#### 延伸思考：這個機制可以用在哪裡？

**適用場景：**
- **電子商務網站**：防止駭客在釣魚網站放置「一鍵購買」按鈕
- **社群媒體平台**：防止惡意網站偽造「發布貼文」或「刪除帳號」的請求
- **網路銀行系統**：確保每一筆轉帳都是用戶在銀行官網親自操作

**關鍵啟示：** 任何涉及「狀態改變」的操作（新增、修改、刪除），都應該用 CSRF 保護。

#### ⚠️ 常見錯誤 / 誤解

- **把 Token 存在 localStorage**：Token 應該由伺服器產生與維護，存在 localStorage 或 sessionStorage 會被 XSS 輕鬆竊取。
- **整頁快取**：若 CDN 快取含有 CSRF Token 的頁面，會導致所有訪客拿到同一組 Token，等同於失效。
- **只在部分路由檢查**：任何改變伺服器狀態的 POST/PUT/DELETE 都要檢查 Token。

---

### 第 4 層：Session - 保護使用者的登入狀態

#### 是什麼？

我們使用 `express-session` 來管理使用者登入後的狀態。但僅僅能用是不夠的，安全的設定至關重要。

#### 為什麼重要？

如果 Session 管理不當，攻擊者可能會：
- 竊取其他使用者的 Session（通過 XSS 或中間人攻擊）
- 偽造新的 Session（如果密鑰不夠強）
- 長期使用過期的 Session（如果沒有設定過期時間）

#### 它具體做了什麼？

我們的安全設定包括：

- **`secret: process.env.SESSION_SECRET`**：用於簽名 Session ID Cookie 的密鑰。一個長且隨機的密鑰可以防止攻擊者偽造 Session。
- **`cookie.httpOnly: true`**：此設定禁止客戶端的 JavaScript 存取 Session Cookie。這能有效防禦 XSS 攻擊者竊取使用者的 Session。
- **`cookie.secure: true`** (在正式環境中)：此設定確保 Session Cookie 只在 HTTPS 連線下被傳輸，防止在不安全的 HTTP 連線中被竊聽。
- **`cookie.sameSite: 'strict'`**：這是防禦 CSRF 的另一道重要防線，它告訴瀏覽器完全不要在跨站請求中發送此 Cookie。

#### 簡單來說...

> **Session 像是遊樂園的「手環」。入園時工作人員給您一個獨特的手環，之後您玩每個設施時只需出示手環即可，不用每次都重新買票。`httpOnly` 確保手環無法被偷走，`secure` 確保手環只在安全通道傳遞，`sameSite` 確保手環只在本遊樂園內有效。**

#### 在金流實戰包中的實例

在系統架構的「流程一」中，使用者透過 Google OAuth 登入後，後端建立一個 Session 並發送給前端一個加密的 Session Cookie。在之後的每次請求中（如下訂單、檢查登入狀態），前端會自動附上這個 Cookie。我們的安全設定確保了：

1. 即使攻擊者透過 XSS 執行了 JavaScript，也無法透過 `document.cookie` 讀取此 Session（因為 `httpOnly: true`）
2. 在線上環境中，Session 只在 HTTPS 下傳輸，不會在 HTTP 中洩露
3. 即使攻擊者從其他網站試圖偽造請求，瀏覽器也不會自動附上 Session Cookie（因為 `sameSite: 'strict'`）

#### 延伸思考：這個機制可以用在哪裡？

**適用場景：**
- **會員制網站**：購物網站記住「您已登入」的狀態
- **線上學習平台**：記錄學員的學習進度
- **專案管理工具**：記住團隊成員的身份和權限

**關鍵啟示：** 任何需要「記住使用者狀態」的應用，都應該用這些設定保護 Session。

#### ⚠️ 常見錯誤 / 誤解

- **使用隨便的 `SESSION_SECRET`**：太短或硬編碼在 repo 中的密鑰，等同邀請他人偽造 Session。
- **忘記在 Proxy 後啟用 `trust proxy`**：部署在 Zeabur 或其他平台時，若未設定 `app.set('trust proxy', 1)`，`cookie.secure` 可能判斷錯誤。
- **把 Session 存在預設記憶體 store**：`express-session` 的 MemoryStore 只適合開發環境，正式環境應改用 Redis 等集中式儲存。

---

### 第 5 層：AES-256-GCM - 保護您的敏感資料

#### 是什麼？

AES 是當今最安全的對稱加密標準之一。`256` 代表其金鑰長度，強度極高。而 `GCM` (Galois/Counter Mode) 模式則更進一步，它在加密的同時加入了「身份驗證」，確保資料在傳輸過程中不僅未被竊聽，也未被篡改。

#### 為什麼重要？

**重要提示**：AES-256-GCM 不只是我們的選擇，它是 **Payuni 金流平台指定的加密標準**。當您與 Payuni 通訊時（特別是在流程二和流程三中），必須使用 AES-256-GCM 進行加密與解密。

#### 它具體做了什麼？

`utils/crypto.js` 中為您封裝了易於使用的 `encrypt` 和 `decrypt` 函式。您可以利用它們來：

- 在將資料發送到第三方服務（如 Payuni）前，對部分敏感欄位進行加密。
- 在資料庫中儲存某些敏感資訊（例如 API 金鑰）時，對其進行加密儲存。
- 保護 Webhook 傳輸的資料。

#### 簡單來說...

> **AES-256-GCM 像是「軍事級保險箱 + 防拆封條」的組合。不僅資料被鎖在保險箱裡（加密），還有防拆封條確保沒有人偷偷打開過（身份驗證）。**

#### 在金流實戰包中的實例

在系統架構的「流程二」和「流程三」中，加密是關鍵：

- **流程二**：當前端要向 Payuni 發起支付時，後端使用 AES-256-GCM 加密訂單資料，產生 `TradeInfo`（加密後的訂單）與 `TradeSha`（簽名），確保 Payuni 收到的資訊完整且未被竄改。

- **流程三**：當 Payuni 的伺服器發送 Webhook 通知時，後端使用 `utils/crypto.js` 中的解密函式，驗證 Webhook 內容的真實性和完整性。如果任何資料被篡改或簽名不正確，解密會失敗，訂單不會被認可為成功。

這確保了整個交易過程中，關鍵的金流資料始終處於加密保護之下，即使網路被中間人攔截也無法看到或篡改內容。

#### 延伸思考：這個機制可以用在哪裡？

**適用場景：**
- **雲端檔案儲存服務**：Dropbox 或 Google Drive 在上傳敏感文件前先加密
- **醫療資訊系統**：醫院與保險公司交換病患資料時加密
- **物聯網設備通訊**：智慧家電與手機 App 之間的通訊加密

**關鍵啟示：** 任何需要與第三方服務安全通訊的場景，或需要儲存高敏感資料時，都應該使用這種「加密 + 驗證」的雙重保護。

#### ⚠️ 常見錯誤 / 誤解

- **重複使用同一組 IV**：GCM 模式必須為每次加密產生新的 Initialization Vector，否則加密強度大幅下降。
- **把 `HashKey` / `HashIV` 寫進程式碼庫**：金鑰應只存在 `.env` 或密鑰管理服務，否則版本控管會留下永久紀錄。
- **混用不同的編碼/排序**：Payuni 的 `TradeSha` 計算對大小寫、欄位順序極度敏感。

---

## 📊 重點回顧

讀完本文後，您應該理解了：

✅ **Helmet** 為什麼能透過 HTTP 標頭防止 XSS、點擊劫持等常見攻擊  
✅ **CORS** 為什麼只允許來自自己網站的前端請求您的 API  
✅ **CSRF Token** 為什麼能防止惡意網站代表使用者發起請求  
✅ **Session 安全設定** 中每一項參數（`httpOnly`、`secure`、`sameSite`）的具體用途  
✅ 什麼時候應該用 **AES-256-GCM 加密**、它怎麼同時保證機密性和完整性

**這些機制並非個別獨立，而是彼此配合，形成一個多層防禦體系。**

---

## 📚 下一步

| 如果你想... | 推薦閱讀 |
|-----------|--------|
| **客製化這套方案** | `動手實踐` |
| **部署到線上環境** | 內部文件 `04_DEPLOYMENT.md` |
| **複習系統流程** | 回到系統架構看各流程如何應用這些防護 |
| **還有其他疑問** | 回到設計理念了解整體思考邏輯 |

---

## 💡 最後提醒

**安全不是一次性的工作，而是持續的責任。** 當您客製化或擴充功能時，請務必：

1. **不要移除或禁用任何現有的安全機制**，除非您完全理解其影響
2. **為新增功能套用相同的防護原則**
3. **定期檢查 `.env` 文件**，確保所有金鑰都是強隨機字符串且不被外洩

> 您的使用者信任您；請用這些工具好好保護他們。

*定位補述：本份安全深度解析已與策略文件同步，未來如要新增安全主題，請先對照該報告確保語氣與重點仍在「教學優先、能力為主」的框架內。*
