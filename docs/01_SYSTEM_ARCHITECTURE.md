# 系統架構

這一章是你進入「金流架構思維實戰教學包」的核心觀察地點。透過這份架構圖與流程拆解，我們不只是讓你知道鏈接了哪些服務，而是希望你能直接練習「如何看懂一個系統、分辨每一層的責任、以及何時要加一道防線」。

理解各個環節如何互動後，你就能清楚判斷該在哪裡放驗證、該在哪裡監控、該如何延伸成下一個能力型專案。
同時也是後續進行客製化與功能擴充的關鍵。

---

## 📚 閱讀順序建議

1. **先讀** `00_DESIGN_PHILOSOPHY.md`
   → 理解「為什麼」設計成這樣

2. **再讀本文**
   → 理解「具體怎麼做」

3. **接著根據需求深入**
   - 關注安全細節？ → `02_SECURITY_DEEP_DIVE.md`
   - 想自己實作？ → `03_CUSTOMIZATION_GUIDE.md`
   - 準備部署上線？ → `04_DEPLOYMENT.md`

---

## 1. 核心元件拆解

我們的系統主要由以下幾個核心元件組成：

| 元件                | 技術/服務                            | 扮演的角色                                                                                             |
| :------------------ | :----------------------------------- | :----------------------------------------------------------------------------------------------------- |
| **前端 (Frontend)** | `HTML`, `CSS`, `JavaScript`          | **使用者介面**：呈現商品、處理 Google 登入、觸發購買流程、跳轉 Payuni UPP 支付頁面、顯示支付結果。     |
| **後端 (Backend)**  | `Node.js` / `Express.js`             | **伺服器中心**：串連所有服務的核心，負責處理業務邏輯、驗證與安全性。                                   |
| **支付閘道**        | `Payuni API`                         | **金流方**：接收訂單資訊並建立付款頁面，於金流方平台進行實際的支付流程，我們的系統不經手任何支付過程。 |
| **身份驗證**        | `Google OAuth 2.0`                   | **使用者身份**：提供一個安全、可信賴的第三方登入機制，避免惡意註冊、以及增加資料管理成本。             |
| **人機驗證**        | `Cloudflare Turnstile`               | **機器人防護**：以對使用者友善的方式 (非 Recaptcha)，過濾惡意機器人流量。                              |
| **資料庫**          | `Google Apps Script / n8n` + `Sheet` | **訂單資料儲存**：一個無伺服器、高可用性且免費的訂單儲存解決方案。                                     |

### 🔍 元件責任與信任邊界

讀完上表，你會注意到每個元件都「只做自己的事」。這不是巧合，而是「關注點分離」的體現——回顧 `00_DESIGN_PHILOSOPHY.md`，這正是我們說的第 2 個挑戰的解決方案。

| 元件 | 它負責什麼 | 它不負責什麼 | 為什麼這樣分工 |
|------|----------|-----------|------------|
| **前端** | 呈現、收集使用者輸入、呼叫 API | 驗證、加密、儲存敏感資料 | 前端可被篡改，不能信任 |
| **後端** | 驗證、加密、業務邏輯 | 呈現介面、直接處理支付 | 後端可信，但要與支付隔離 |
| **Payuni** | 支付流程、金鑰管理 | 驗證訂單、修改金額 | 金流方專注金流，不掌握業務 |
| **資料庫** | 儲存最終結果 | 驗證訂單、加密敏感資料 | 資料庫只是倉庫，需要資料已驗證 |

這個分工模式，將在「自我檢核」和「設計啟示」中不斷出現。理解這個邏輯後，你就能在未來的專案中清楚地畫出「信任邊界」。

---

## 2. 核心流程詳解

理解以下三個核心流程，您就能掌握整個系統的運作精髓。

### 流程一：使用者登入 (Google OAuth 2.0)

> **情境提要：**
> 想像顧客來到店裡，我們需要知道他是誰 (至少要是人)，於是他在消費之前須要登入 Google 驗證身份。
>
> 驗證完畢後，Google 會給顧客一串**『驗證碼』**（Authorization Code），並讓他帶回來交給我們的後台。
>
> 我們伺服器收到這串驗證碼後，會**再次**跟 Google 確認是否有效，確認無誤後，**才會發給顧客一張允許消費的『通行證』（Session Cookie）**。
> 此時你可以將這位顧客加入會員資料。

```mermaid
graph TD
    A[使用者] --> B{點擊使用 Google 登入}
    B --> C[前端 index.html]
    C --> D{重導向至 Google 驗證頁面}
    D --> E[Google 驗證頁面]
    E --> F{使用者登入並授權}
    F --> G{Google 重導向至後端 Callback URL}
    G --> H[後端伺服器 /auth/google/callback]
    H --> I{向 Google 交換 Access Token}
    I --> J[取得使用者資料]
    J --> K{建立 Session}
    K --> L{發送 Session Cookie}
    L --> M{重導向至首頁}
    M --> N[前端 index.html]
    N --> O{更新 UI 顯示使用者資訊}
```

1.  **觸發**：使用者在 `index.html` 上點擊「使用 Google 登入」。
2.  **重導向至 Google**：瀏覽器被導向至 Google 的身份驗證頁面。
3.  **使用者授權**：使用者在 Google 頁面登入並同意授權。
4.  **回呼 (Callback)**：Google 將使用者導回至我們後端設定的 `GOOGLE_REDIRECT_URI` (`/auth/google/callback`)，並附帶一個授權碼 (Authorization Code)。
5.  **後端驗證**：我們的 Express 伺服器收到授權碼後，在後端向 Google 交換存取權杖 (Access Token)，並用權杖取得使用者資料（名稱、頭像等）。
6.  **建立 Session**：伺服器為該使用者建立一個 Session，並將使用者資訊存入其中，同時向瀏覽器發送一個加密的 Session Cookie。
7.  **重導向至首頁**：伺服器將使用者導回網站首頁。前端偵測到登入狀態，更新 UI，顯示使用者名稱與頭像。

#### 自我檢核：登入流程

**🔰 基礎理解**（看懂流程）
- 如果 Google 回傳的授權碼無效，流程會停在哪一層？

**🌟 進階思考**（理解原理）
- 為什麼我們不能相信瀏覽器直接傳來的授權碼，而要在後端再驗證一次？
- 介面或日誌會出現哪些訊號，幫助你辨識登入失敗的原因？

**🌟🌟 應用能力**（遷移到新場景）
- 若要改成 GitHub OAuth，哪些設定可以沿用、哪些必須重新建立？

### 流程二：建立訂單與前往支付

> **情境提要：**
> 顧客決定購買後，我們會先將這次的交易輸入資料庫，因為我們不確定付款過程會不會出現錯誤、顧客可能拿出錢包時發現身上錢不夠，以及我們也需要讓付款結果與我們的資料庫是可以對應的(可追溯)。
> 在這個過程中，我們會確認顧客身份等驗證都沒問題後，在資料庫建立一筆正式訂單，並將所有內容加密交予顧客，並引導他去金流平台頁面進行付款。

```mermaid
graph TD
    A[已登入使用者] --> B{點擊立即購買}
    B --> C[前端 index.html]
    C --> D{POST 請求至後端 /api/create-order}
    D --> E[後端伺服器]
    E --> F{驗證 Session 和 CSRF Token}
    F --> G{查詢商品資料 data/products.js}
    G --> H{產生訂單資料 和 MerchantOrderNo}
    H --> I{加密訂單資料 TradeInfo 和 TradeSha}
    I --> J{回傳 Payuni 支付所需資訊給前端}
    J --> K[前端 index.html]
    K --> L{自動提交表單至 Payuni 支付頁面}
    L --> M[Payuni 支付頁面]
```

1.  **觸發**：已登入的使用者在 `index.html` 上點擊「立即購買」。
2.  **前端請求**：前端 JavaScript 向後端的 `/api/create-order` 端點發起一個 `POST` 請求，請求中包含商品 ID 與 CSRF Token。
3.  **後端處理**：
    a. 伺服器驗證使用者的 Session 與 CSRF Token，確保請求合法。
    b. 根據商品 ID 從 `data/products.js` (或者你可以從資料庫獲取) 查找價格與商品名稱。
    c. 產生一筆新的訂單資料，包含唯一的訂單號 (`MerchantOrderNo`)。
    d. 將訂單資料與 Payuni 的 `HashKey` 及 `HashIV` 進行加密，產生 `TradeInfo` (加密後的訂單) 與 `TradeSha` (簽名)。
4.  **回傳給前端**：後端將 `TradeInfo`、`TradeSha` 及 Payuni 的 API 端點等必要資訊回傳給前端。
5.  **跳轉至 Payuni**：前端收到後端的回應後，會動態建立一個表單，並自動將這些資訊 `POST` 到 Payuni 的支付頁面。此時，使用者的瀏覽器畫面會從您的網站跳轉到 Payuni 的網站。

#### 自我檢核：建立訂單流程

**🔰 基礎理解**（看懂流程）
- 建立訂單時，為什麼要用 CSRF Token？

**🌟 進階思考**（理解原理）
- 如果前端漏附 CSRF Token，後端如何偵測並拒絕？
- 當 Payuni API 規格更新時，哪些檔案和環境變數需要同步檢查？

**🌟🌟 應用能力**（遷移到新場景）
- 在什麼情境下你需要重新產生 `MerchantOrderNo`？
- 如果要改用不同的支付服務，這個流程中哪些地方需要改？

---

### 🚀 難度升級提示

讀到這裡，你已經理解了「使用者登入」和「建立訂單」這兩個相對直線性的流程。接下來的「Webhook 流程」會更複雜，因為涉及**異步通訊、兩條平行路線、加密驗證**等多個層面。

建議在讀流程三前，回頭快速複習一下 `00_DESIGN_PHILOSOPHY.md` 的「挑戰 3：支付成功的確定性」，這會幫你理解「為什麼需要這樣設計」，再來看技術細節就會清楚許多。

---

### 流程三：支付確認與訂單紀錄 (Webhook)

> **情境提要：**
> 在顧客付款成功後，金流平台會將結果通知我們和顧客：
>
> 1.  **Return URL**：付款成功後，顧客會被告知已經付款了，形式可以由我們決定，可能是一張紙、可能只是一個訊息...etc。
>
>     - **不可盡信**：它只是一個快速的操作回饋、非正式的通知。
>
> 2.  **Notify URL**：幾乎在同一時間，金流平台會透過這個管道，將交易內容加密、送到我們處理專門 Notify 的地方。
>     - **唯一可信**：我們收到後，會解密內容並驗證是否有效。只有這則通知內容確認無誤，我們才會同步紀錄到會員的購買資料。

這是整個流程中相當關鍵的一步，它確保了交易的最終一致性。

```mermaid
graph TD
    A[使用者] --> B{在 Payuni 頁面完成支付}
    B --> C1[Payuni 前端重導向]
    C1 --> D1[前端 result.html 顯示結果]
    B --> C2[Payuni 伺服器 後端 Webhook]
    C2 --> D2{POST 請求至後端 /payuni-webhook}
    D2 --> E[後端伺服器]
    E --> F{解密與驗證 Webhook 內容}
    F --> G{確認訂單支付成功}
    G --> H{整理訂單資料}
    H --> I{POST 請求至 GAS_WEBHOOK_URL}
    I --> J[Google Apps Script GAS]
    J --> K{執行 doPost 函式}
    K --> L[Google Sheet 新增訂單紀錄]
```

1.  **使用者支付**：使用者在 Payuni 頁面輸入信用卡資訊並完成支付。
2.  **兵分兩路**：
    - **路徑 A (前端)**：Payuni 將使用者的瀏覽器導回到您指定的 `PAYUNI_RETURN_URL` (`result.html`)。**這僅用於提供即時的使用者體驗，不應作為訂單成功的依據。**
    - **路徑 B (後端 - 真實的交易通知)**：在背景，Payuni 的伺服器會向您在 `.env` 中設定的 `NOTIFY_URL` (`/payuni-webhook`) 發送一個 `POST` 請求。這就是「Webhook」，是唯一可信的交易結果通知。
3.  **後端接收 Webhook**：您的 Express 伺服器接收到這個 Webhook 請求。
4.  **解密與驗證**：伺服器使用 `utils/crypto.js` 中的 AES-256-GCM 解密函式，對 Webhook 內容進行解密與驗證。這一步確保了通知確實來自 Payuni 且內容未被篡改。
5.  **確認訂單成功**：驗證成功後，後端即可 100% 確認這筆訂單已支付成功。
6.  **觸發 GAS**：後端將訂單號、金額、商品名稱、使用者等關鍵資訊，整理成一個乾淨的 JSON 物件。
7.  **寫入 Google Sheet**：後端向您在 `.env` 中設定的 `GAS_WEBHOOK_URL` 發起一個 `POST` 請求，將上述 JSON 物件傳送過去。
8.  **GAS 執行**：部署在雲端的 Google Apps Script 被觸發，執行 `doPost` 函式，將接收到的 JSON 資料新增一行到您指定的 Google Sheet 中，完成訂單的最終紀錄。

#### 自我檢核：Webhook 流程

**🔰 基礎理解**（看懂流程）
- 為什麼需要兩條通知路線（Return URL 和 Notify URL）？

**🌟 進階思考**（理解原理）
- 如果 Payuni Webhook 遲遲未到，你還能從哪裡追蹤交易狀態？
- 當 `utils/crypto.js` 的解密失敗時，會拋出哪些錯誤訊息或日誌線索？

**🌟🌟 應用能力**（遷移到新場景）
- 如果要改用資料庫而非 Google Sheet，這條流程需要替換哪幾個節點？
- 除了 Webhook，還有其他「最終確認」機制嗎？在什麼場景會用？

---

## 3. 結論

你可以注意到，我們的所有流程都相當強調「驗證有效性」這點。
不論是透過 Google 登入來驗證使用者是否正常、將所有敏感資訊加密、使資料可追溯、使用 CSRF Token 等各種機制來防止偽造請求、完全由後端進行最終支付資料的加密/解密與驗證來確保支付的有效性。

每一道防線都是為了確保：

1. **使用者身份真實**：只有真正的使用者才能存取系統。
2. **請求合法有效**：盡可能所有操作都來自可信來源，增加惡意使用者的成本與門檻。
3. **資料完整未篡改**：任何傳輸中的資料都經過加密與簽名驗證。
4. **交易結果可追溯**：確保訂單紀錄與金流方平台一致。

因此，當你在客製化或擴充功能時，**永遠要記住保護這些驗證環節的重要性**。
不要跳過任何簽名檢查、Session 驗證或加密步驟，因為這些看似「麻煩」的機制，才是保護你和你用戶資料安全的關鍵。

---

## 設計啟示：從金流案例學到的可轉移技能

讀完這份系統架構，你不只學會了「金流怎麼串」，更重要的是學會了以下可以應用在任何專案的設計原則：

### 1. 多層驗證的思維
**在金流案例中的體現：**
- Google OAuth 驗證使用者身份
- Session Cookie 維持登入狀態
- CSRF Token 防止跨站攻擊
- Webhook 簽名驗證支付結果

**可應用的場景：**
任何需要保護使用者資料的系統都需要這種「不信任任何單一防線」的思維。例如：
- 會員系統：登入 + 二次驗證 + 操作確認
- 訂單系統：身份驗證 + 庫存檢查 + 支付確認
- 內容管理：權限驗證 + 操作日誌 + 審核機制

**核心啟示：** 永遠不要假設「前一步驗證過了，這一步就安全」。每一層都要獨立驗證。

### 2. 關注點分離的架構
**在金流案例中的體現：**
- 前端：只負責 UI 展示和使用者互動
- 後端：處理業務邏輯、驗證和資料處理
- Payuni：專注處理支付流程
- Google Sheets/GAS：單純儲存訂單資料

**可應用的場景：**
任何需要整合多個服務或長期維護的專案：
- 社群登入整合（OAuth 提供者 + 你的系統 + 資料庫）
- 第三方 API 串接（外部服務 + 中間層 + 你的業務邏輯）
- 微服務架構（各服務獨立部署、各司其職）

**核心啟示：** 當每個部分只做一件事且做好時，系統更容易理解、測試和維護。

### 3. 非同步通訊的處理
**在金流案例中的體現：**
- **Return URL**：使用者支付完成後的「即時回饋」（前端體驗）
- **Notify URL (Webhook)**：Payuni 伺服器的「非同步通知」（真實交易結果）

**可應用的場景：**
任何需要處理「不會立即完成的任務」：
- 發送郵件（觸發後背景處理，不阻塞使用者）
- 產生報表（運算時間長，用 Webhook 通知完成）
- 批次處理（大量資料處理，進度通知）
- 第三方服務整合（等待外部回應）

**核心啟示：** 區分「使用者需要立即看到的回饋」和「真正完成的確認」，設計更可靠的系統。

### 4. 安全優先的設計原則
**在金流案例中的體現：**
- 所有敏感資訊都加密傳輸（AES-256-GCM）
- 所有 API 金鑰都存在 `.env` 而非程式碼中
- 永遠不經手信用卡資訊（委託給 Payuni）
- 使用 `httpOnly` Cookie 防止 XSS 竊取 Session

**可應用的場景：**
任何處理敏感資料的專案：
- 健康醫療資料（加密儲存、傳輸、存取控制）
- 財務資訊（最小權限、審計日誌、多重驗證）
- 個人隱私（資料去識別化、同意管理）

**核心啟示：** 「安全」不是功能做完後才加上去的，而是從設計之初就要內建的。

---

## 從案例到能力

當你在未來的專案中遇到以下情境時，回想這個金流案例的設計邏輯：

| 你遇到的情境 | 金流案例的對應概念 | 可借鑒的設計 |
|------------|-----------------|------------|
| 需要整合第三方 API | Payuni 金流整合 | 加密通訊、Webhook 驗證 |
| 需要保護使用者操作 | CSRF Token、Session | 多層驗證、權杖機制 |
| 需要處理非同步任務 | Webhook 通知 | 回調機制、狀態管理 |
| 需要設計資料流 | 訂單從前端到資料庫 | 關注點分離、資料驗證 |
| 需要管理敏感資訊 | API Keys、Session Secret | 環境變數、加密儲存 |

**記住**：架構設計的核心不是「知道有哪些技術」，而是「理解為什麼要這樣組合」。這套金流系統就是一個最好的示範。

---

## 4. 專案檔案結構解析

```
.
├── docs/           # 深度導覽文件 (就是這裡)
├── @gas/             # Google Apps Script
│   └── code.gs       # 接收後端通知並寫入 Sheet 的邏輯
├── @n8n/             # (選配) n8n 自動化工作流範本
├── data/             # 您的商品目錄
│   └── products.js   # 在此新增或修改商品
├── logs/             # 伺服器日誌存放目錄，用於問題排查
├── public/           # 前端靜態檔案 (CSS, JS, 圖片等)
│   ├── app.js        # 前端主要邏輯 (如點擊事件、API 請求)
│   └── result.js     # 支付結果頁的邏輯
├── utils/            # 後端共用的工具函式
│   ├── crypto.js     # 核心加密/解密函式 (AES-256-GCM)
│   └── logger.js     # 日誌記錄器設定 (Winston)
├── .env.example      # 環境變數的範本，所有機敏資訊都在此設定
├── index.js          # Express 後端主應用程式，所有 API 端點與邏輯的入口
├── index.html        # 主要商品頁 (首頁)
├── result.html       # 支付結果頁
└── package.json      # 專案依賴與腳本設定
```

理解這個架構後，您就能清晰地知道，當需要修改某個功能時，應該從哪個檔案或哪個資料夾著手。

---

## 下一步！

| 如果你想...              | 推薦閱讀                                     |
| ------------------------ | -------------------------------------------- |
| **深入了解安全防護機制** | `02_SECURITY_DEEP_DIVE.md`                   |
| **自己客製化這套方案**   | `03_CUSTOMIZATION_GUIDE.md`                  |
| **部署到線上環境**       | `04_DEPLOYMENT.md`                           |
| **遇到問題找答案**       | 查看本文檔對應的流程段落，或參考 `README.md` |

---

## 📚 本章學到的能力（自我檢核清單）

讀完本章，你應該能做到以下事項。如果某項還不確定，建議回頭複習對應段落。

| 你練習到的能力 | 檢核方式 | 進階應用 |
| --- | --- | --- |
| **系統拆解** | 能畫出「前端→後端→第三方→資料庫」的資料流 | 把這套模型套到你自己的專案上 |
| **信任邊界判斷** | 能說清楚「為什麼前端不能信」、「為什麼後端要再驗一次」 | 在設計新 API 時，清楚地標出「信任邊界」 |
| **非同步設計思維** | 理解「Return URL vs Webhook」的差異，知道何時該用哪個 | 在下一個非同步任務（郵件、報表）中應用 |
| **防線設計** | 能指出每個流程中「驗證、加密、防偽造」在哪裡發生 | 為新功能補上適當的防線 |

---

> 📌 **定位補述**：這份架構解說已依據 `AI_OUTPUTS/Pivoted_Payment_Gateway_Strategy.md` 的新定位重寫，請在擴充或補充內容前先對照該報告，確保每個細節仍在「能力導向、教學優先」的框架下。
