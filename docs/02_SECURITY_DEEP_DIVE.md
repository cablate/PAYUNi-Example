# 安全性深度解析 (Security Deep Dive)

歡迎來到「金流整合實戰包」的安全性核心。線上交易的基礎是信任，而信任來自於強大的安全機制。本文件將深入探討此專案中為您內建的各項安全機制，讓您不僅知道「如何使用」，更理解「為何如此設計」。

我們採用了「深度防禦 (Defense in Depth)」策略，透過多層次的防護，即使某一層被繞過，其他層依然能保護您的應用程式與使用者資料。

---

## 進階安全深潛指南

### 閱讀前提

- 建議先讀 [00_DESIGN_PHILOSOPHY.md](./00_DESIGN_PHILOSOPHY.md) 了解設計理念
- 建議先讀 [01_SYSTEM_ARCHITECTURE.md](./01_SYSTEM_ARCHITECTURE.md) 了解系統流程

### 本文件涵蓋

在 [01_SYSTEM_ARCHITECTURE.md](./01_SYSTEM_ARCHITECTURE.md) 中，我們提到「每一步都有驗證、加密、防止偽造」。
本文件深入講解**具體是用什麼技術來實現這些防護**。

### 讀完後可以

- 理解為什麼每個安全設定都很重要
- 知道哪些參數不應該亂改
- 為未來的客製化與部署奠定安全基礎

---

## 1. Helmet - 您的第一道 HTTP 防線

**是什麼？**
`Helmet` 是一個 Express 中介軟體，它本身是 15 個小型中介軟體的集合，專門用來設定與安全性相關的 HTTP 標頭 (HTTP Headers)。

**為什麼重要？**
許多常見的 Web 攻擊，如跨站腳本攻擊 (XSS)、點擊劫持 (Clickjacking)，都可以透過正確設定 HTTP 標頭來防範。Helmet 為您自動處理了這些繁瑣但至關重要的設定。

**在此專案中，Helmet 為您做了什麼？**

- **`Strict-Transport-Security`**: 強制瀏覽器只能使用 HTTPS 與您的伺服器通訊，杜絕中間人攻擊。
- **`X-Content-Type-Options`**: 防止瀏覽器「猜測」檔案類型，避免惡意檔案被當作可執行腳本。
- **`X-Frame-Options`**: 防止您的網頁被嵌入到 `<iframe>` 中，防禦點擊劫持攻擊。
- **`Content-Security-Policy`**: (可選，但功能強大) 能精確定義允許載入哪些來源的腳本、樣式、圖片等，是防禦 XSS 的利器。
- ...以及其他多項標頭設定。

> **簡單來說，Helmet 就像是為您的網站聘請了一位全天候的保全，檢查所有進出的網路請求，確保它們符合安全規範。**

**在金流實戰包中的實例**
每當使用者透過瀏覽器訪問您的網站時（無論是首次載入 `index.html`、完成 Google 登入後的重導向、或是顯示支付結果的 `result.html`），Helmet 都會自動在回應中附加這些安全標頭。例如：

- 當 Payuni 的支付頁面完成後，使用者被導回您的 `result.html` 時，Helmet 確保了即使該頁面被嵌入到惡意頁面的 `<iframe>` 中，瀏覽器也會拒絕執行。
- 所有 API 請求的回應都強制使用 HTTPS，防止通訊被中間人攔截。

---

## 2. CORS (跨來源資源共用) - 精準控制 API 存取

**是什麼？**
CORS 是一種瀏覽器安全機制，它限制了網頁只能請求與自己「同來源」(Same-Origin) 的資源。當您需要從 `your-domain.com` 的前端去請求 `api.your-domain.com` 的後端時，就需要 CORS 規則來「放行」。

**在此專案中，我們如何設定？**
在 `index.js` 中，我們使用 `cors` 中介軟體，並設定只允許來自您在 `.env` 檔案中指定的 `DOMAIN` 的請求。

**為什麼這很重要？**
如果沒有正確設定，任何惡意網站都可以透過其前端 JavaScript，向您的後端 API 發起請求（例如，嘗試代表已登入的使用者下訂單）。我們的設定確保了只有您自己的網站前端，才有權限與您的後端伺服器溝通。

**在金流實戰包中的實例**
在「系統架構」的三個流程中，前端都需要向後端 API 發起請求：

- **流程一**：前端請求 `/auth/google/callback` 以完成登入
- **流程二**：前端請求 `/api/create-order` 建立訂單
- **流程三**：後端向 Payuni 的 Webhook 回應

CORS 設定確保了只有來自您在 `.env` 中指定的 `DOMAIN` 的請求才會被接受。舉例，如果 `DOMAIN=https://myshop.com`，那麼即使有人在 `https://malicious.com` 上寫的 JavaScript 試圖呼叫您的 API，瀏覽器也會基於 CORS 政策直接拒絕該請求。

---

## 3. CSRF (跨站請求偽造) - 保護使用者操作的真實性

**是什麼？**
CSRF 是一種常見的攻擊，攻擊者在自己的網站上放置一個陷阱（例如，一張看不見的圖片或一個表單），誘騙已在您網站登入的使用者點擊。一旦點擊，使用者的瀏覽器就會在不知情的情況下，向您的伺服器發送一個惡意請求（例如，更改密碼、下訂單）。

**在此專案中，我們如何防禦？**
我們採用了 `csurf` (或類似的 Token-Based 機制)。

1.  當使用者載入您的頁面時，伺服器會產生一個獨一無二、不可預測的 `CSRF Token`。
2.  前端在發起任何會改變狀態的請求（如 `POST` 請求去建立訂單）時，必須在請求中附上這個 Token。
3.  後端在收到請求時，會驗證這個 Token 是否匹配。如果 Token 不存在或不正確，請求將被拒絕。

**為什麼這很重要？**
由於惡意網站無法得知這個獨一無二的 Token，因此它無法偽造出一個能通過驗證的請求。這確保了每一個重要操作，都是由使用者在您的網站上親自發起的。

**在金流實戰包中的實例**
當使用者在 [01_SYSTEM_ARCHITECTURE.md](./01_SYSTEM_ARCHITECTURE.md) 的「流程二」點擊「立即購買」時，前端會：

1. 從伺服器取得最新的 CSRF Token（在頁面載入時）
2. 在 POST 至 `/api/create-order` 時，將此 Token 附在請求中
3. 後端驗證 Token 是否正確，只有通過驗證才會建立訂單

這確保了訂單一定是使用者親自在您的網站上點擊「購買」按鈕發起的，而不是被其他網站的陷阱誘騙。

---

## 4. Session 安全管理 - 保護使用者的登入狀態

**是什麼？**
我們使用 `express-session` 來管理使用者登入後的狀態。但僅僅能用是不夠的，安全的設定至關重要。

**我們的安全設定：**

- **`secret: process.env.SESSION_SECRET`**: 用於簽名 Session ID Cookie 的密鑰。一個長且隨機的密鑰可以防止攻擊者偽造 Session。這就是為什麼我們一再強調 `SESSION_SECRET` 的重要性。
- **`cookie.httpOnly: true`**: 此設定禁止客戶端的 JavaScript 存取 Session Cookie。這能有效防禦 XSS 攻擊者竊取使用者的 Session。
- **`cookie.secure: true`** (在正式環境中): 此設定確保 Session Cookie 只在 HTTPS 連線下被傳輸，防止在不安全的 HTTP 連線中被竊聽。
- **`cookie.sameSite: 'strict'`**: 這是防禦 CSRF 的另一道重要防線，它告訴瀏覽器完全不要在跨站請求中發送此 Cookie。

**在金流實戰包中的實例**
在 [01_SYSTEM_ARCHITECTURE.md](./01_SYSTEM_ARCHITECTURE.md) 的「流程一」中，使用者透過 Google OAuth 登入後，後端建立一個 Session 並發送給前端一個加密的 Session Cookie。在之後的每次請求中（如下訂單、檢查登入狀態），前端會自動附上這個 Cookie。我們的安全設定確保了：

1. 即使攻擊者透過 XSS 執行了 JavaScript，也無法透過 `document.cookie` 讀取此 Session（因為 `httpOnly: true`）
2. 在線上環境中，Session 只在 HTTPS 下傳輸，不會在 HTTP 中洩露
3. 即使攻擊者從其他網站試圖偽造請求，瀏覽器也不會自動附上 Session Cookie（因為 `sameSite: 'strict'`）

---

## 5. AES-256-GCM 加密 (`utils/crypto.js`) - 保護您的敏感資料

**是什麼？**
AES 是當今最安全的對稱加密標準之一。`256` 代表其金鑰長度，強度極高。而 `GCM` (Galois/Counter Mode) 模式則更進一步，它在加密的同時加入了「身份驗證」，確保資料在傳輸過程中不僅未被竊聽，也未被篡改。

**重要提示**
AES-256-GCM 不只是我們的選擇，它是 **Payuni 金流平台指定的加密標準**。當您與 Payuni 通訊時（特別是在流程二和流程三中），必須使用 AES-256-GCM 進行加密與解密。這個實戰包中的 `utils/crypto.js` 已經為您實現了符合 Payuni 規格的加密/解密邏輯。

**您可以用它來做什麼？**
`utils/crypto.js` 中為您封裝了易於使用的 `encrypt` 和 `decrypt` 函式。您可以利用它們來：

- 在將資料發送到第三方服務（如 Payuni）前，對部分敏感欄位進行加密。
- 在資料庫中儲存某些敏感資訊（例如 API 金鑰）時，對其進行加密儲存。
- 保護 Webhook 傳輸的資料。

> **這就像是為您的核心資料提供了一個無法破解的保險箱，並在每次開鎖時都驗證指紋，確保其完整性。**

**在金流實戰包中的實例**
在 [01_SYSTEM_ARCHITECTURE.md](./01_SYSTEM_ARCHITECTURE.md) 的「流程二」和「流程三」中，加密是關鍵：

- **流程二**：當前端要向 Payuni 發起支付時，後端使用 AES-256-GCM 加密訂單資料，產生 `TradeInfo`（加密後的訂單）與 `TradeSha`（簽名），確保 Payuni 收到的資訊完整且未被竄改。
- **流程三**：當 Payuni 的伺服器發送 Webhook 通知時，後端使用 `utils/crypto.js` 中的解密函式，驗證 Webhook 內容的真實性和完整性。如果任何資料被篡改或簽名不正確，解密會失敗，訂單不會被認可為成功。

這確保了整個交易過程中，關鍵的金流資料始終處於加密保護之下，即使網路被中間人攔截也無法看到或篡改內容。

---

## 重點回顧

讀完本文後，您應該理解了：

- **Helmet** 為什麼能透過 HTTP 標頭防止 XSS、點擊劫持等常見攻擊
- **CORS** 為什麼只允許來自自己網站的前端請求您的 API
- **CSRF Token** 為什麼能防止惡意網站代表使用者發起請求
- **Session 安全設定** 中每一項參數（`httpOnly`、`secure`、`sameSite`）的具體用途
- 什麼時候應該用 **AES-256-GCM 加密**、它怎麼同時保證機密性和完整性

這些機制並非個別獨立，而是彼此配合，形成一個**多層防禦體系**。

---

## 下一步

| 如果你想...    | 推薦閱讀                                                                               |
| -------------- | -------------------------------------------------------------------------------------- |
| 客製化這套方案 | [03_CUSTOMIZATION_GUIDE.md](./03_CUSTOMIZATION_GUIDE.md)                               |
| 部署到線上環境 | [04_DEPLOYMENT.md](./04_DEPLOYMENT.md)                                                 |
| 複習系統流程   | 回到 [01_SYSTEM_ARCHITECTURE.md](./01_SYSTEM_ARCHITECTURE.md) 看各流程如何應用這些防護 |
| 還有其他疑問   | 參考 [00_DESIGN_PHILOSOPHY.md](./00_DESIGN_PHILOSOPHY.md) 了解整體思考邏輯             |

### 最後提醒

安全不是一次性的工作，而是持續的責任。當您客製化或擴充功能時，請務必：

1. **不要移除或禁用任何現有的安全機制**，除非您完全理解其影響
2. **為新增功能套用相同的防護原則**
3. **定期檢查 `.env` 文件**，確保所有金鑰都是強隨機字符串且不被外洩

您的使用者信任您；請用這些工具好好保護他們。
