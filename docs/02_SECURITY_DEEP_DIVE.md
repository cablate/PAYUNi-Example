# 安全性深度解析 (Security Deep Dive)

歡迎來到「金流整合實戰包」的安全性核心。線上交易的基礎是信任，而信任來自於強大的安全機制。本文件將深入探討此專案中為您內建的各項安全機制，讓您不僅知道「如何使用」，更理解「為何如此設計」。

我們採用了「深度防禦 (Defense in Depth)」策略，透過多層次的防護，即使某一層被繞過，其他層依然能保護您的應用程式與使用者資料。

---

## 進階安全深潛指南

### 閱讀前提

- 建議先讀 [00_DESIGN_PHILOSOPHY.md](./00_DESIGN_PHILOSOPHY.md) 了解設計理念
- 建議先讀 [01_SYSTEM_ARCHITECTURE.md](./01_SYSTEM_ARCHITECTURE.md) 了解系統流程

### 本文件涵蓋

在 [01_SYSTEM_ARCHITECTURE.md](./01_SYSTEM_ARCHITECTURE.md) 中，我們提到「每一步都有驗證、加密、防止偽造」。
本文件深入講解**具體是用什麼技術來實現這些防護**。

### 練習的能力
- **判斷防線:** 能看出每一層防護真正解決的是哪種攻擊 (XSS、CSRF、偽造請求等)，並學會替新流程加上類似的保障。
- **控制信任:** 了解哪些資料可以信任、哪些要重新驗證，進而在設計時畫出清晰的信任邊界。
- **細節可追溯:** 練習把抽象規則拆換成可配置的參數 (Helmet 的標頭、CORS 的來源、Session Cookie 的屬性)，這正是「能力型產品」想要傳遞的架構思維。

### 讀完後可以

- 理解為什麼每個安全設定都很重要
- 知道哪些參數不應該亂改
- 為未來的客製化與部署奠定安全基礎

---

## 1. Helmet - 您的第一道 HTTP 防線

**是什麼？**
`Helmet` 是一個 Express 中介軟體，它本身是 15 個小型中介軟體的集合，專門用來設定與安全性相關的 HTTP 標頭 (HTTP Headers)。

**為什麼重要？**
許多常見的 Web 攻擊，如跨站腳本攻擊 (XSS)、點擊劫持 (Clickjacking)，都可以透過正確設定 HTTP 標頭來防範。Helmet 為您自動處理了這些繁瑣但至關重要的設定。

**在此專案中，Helmet 為您做了什麼？**

- **`Strict-Transport-Security`**: 強制瀏覽器只能使用 HTTPS 與您的伺服器通訊，杜絕中間人攻擊。
- **`X-Content-Type-Options`**: 防止瀏覽器「猜測」檔案類型，避免惡意檔案被當作可執行腳本。
- **`X-Frame-Options`**: 防止您的網頁被嵌入到 `<iframe>` 中，防禦點擊劫持攻擊。
- **`Content-Security-Policy`**: (可選，但功能強大) 能精確定義允許載入哪些來源的腳本、樣式、圖片等，是防禦 XSS 的利器。
- ...以及其他多項標頭設定。

> **簡單來說，Helmet 就像是為您的網站聘請了一位全天候的保全，檢查所有進出的網路請求，確保它們符合安全規範。**

**在金流實戰包中的實例**
每當使用者透過瀏覽器訪問您的網站時（無論是首次載入 `index.html`、完成 Google 登入後的重導向、或是顯示支付結果的 `result.html`），Helmet 都會自動在回應中附加這些安全標頭。例如：

- 當 Payuni 的支付頁面完成後，使用者被導回您的 `result.html` 時，Helmet 確保了即使該頁面被嵌入到惡意頁面的 `<iframe>` 中，瀏覽器也會拒絕執行。
- 所有 API 請求的回應都強制使用 HTTPS，防止通訊被中間人攔截。

### 延伸思考：這個機制可以用在哪裡？

**Helmet 適用的場景：**
- 任何面向公眾的網站（部落格、企業官網、電商平台）
- 需要保護使用者免受 XSS 攻擊的應用
- 任何需要防止點擊劫持的頁面（如支付頁面、敏感操作頁面）

**關鍵啟示：** HTTP 標頭是「無形的防護牆」，使用者看不到，但它們時刻在保護著瀏覽器和伺服器之間的通訊安全。

### 真實案例 (Real Case)

#### XSS 攻擊的實際後果

2007 年，Myspace 遭遇了知名的 **Samy XSS 蠕蟲**案例。攻擊者在個人頁面中注入一段JavaScript，當其他使用者訪問該頁面時，蠕蟲會自動執行，將自己複製到訪客的個人頁面。短短數天，超過 100 萬個 MySpace 帳戶被感染。這就是為什麼我們需要 CSP、輸入驗證，以及 Helmet 的 `X-Content-Type-Options` 來防止瀏覽器誤判內容類型。

**參考資料：** [OWASP XSS 攻擊教科書](https://owasp.org/www-community/attacks/xss/)、[Myspace Samy 蠕蟲分析](https://en.wikipedia.org/wiki/Samy_(XSS_worm))

#### HTTP 標頭的重要性

金融機構特別容易成為點擊劫持和中間人攻擊的目標。設定 `Strict-Transport-Security` 可以確保：
- 使用者對銀行網站的第一次訪問也是加密的（防止 SSL Stripping 攻擊）
- 瀏覽器拒絕任何 HTTP 連線，強制轉向 HTTPS
- 即使網路受到干擾，使用者仍然得到保護

沒有這層防護，駭客可以攔截使用者的 HTTP 請求，並在其中注入內容或竊聽敏感資訊。

### 業界背景 (Industry Context)

Helmet 中的 HTTP 安全標頭設定已被納入：
- **OWASP Top 10**：作為防禦 XSS 和其他 Web 攻擊的推薦做法
- **PCI DSS (Payment Card Industry Data Security Standard)**：第 6.5.7 條要求應用必須防禦 XSS
- **Mozilla Web Security 標準**：瀏覽器廠商聯合推薦的安全最佳實踐

在您的支付應用中使用 Helmet，不只是提升安全性，也是符合國際支付標準的必要措施。

#### ⚠️ 常見錯誤 / 誤解

- **只在本機啟用 HTTPS**：一旦上線卻仍允許 HTTP，就等於關掉 `Strict-Transport-Security` 的效益。
- **自訂 CSP 時全部改成 `*`**：放寬 `Content-Security-Policy` 會讓 XSS 防線瞬間崩潰，寧可逐一列出合法來源。
- **局部路由關閉 Helmet**：為了某個第三方 widget 關閉整組標頭，很容易遺漏重新開啟，請改成有條件地調整單一標頭。

---

## 2. CORS (跨來源資源共用) - 精準控制 API 存取

**是什麼？**
CORS 是一種瀏覽器安全機制，它限制了網頁只能請求與自己「同來源」(Same-Origin) 的資源。當您需要從 `your-domain.com` 的前端去請求 `api.your-domain.com` 的後端時，就需要 CORS 規則來「放行」。

**在此專案中，我們如何設定？**
在 `index.js` 中，我們使用 `cors` 中介軟體，並設定只允許來自您在 `.env` 檔案中指定的 `DOMAIN` 的請求。

**為什麼這很重要？**
如果沒有正確設定，任何惡意網站都可以透過其前端 JavaScript，向您的後端 API 發起請求（例如，嘗試代表已登入的使用者下訂單）。我們的設定確保了只有您自己的網站前端，才有權限與您的後端伺服器溝通。

**在金流實戰包中的實例**
在「系統架構」的三個流程中,前端都需要向後端 API 發起請求：

- **流程一**：前端請求 `/auth/google/callback` 以完成登入
- **流程二**：前端請求 `/api/create-order` 建立訂單
- **流程三**：後端向 Payuni 的 Webhook 回應

CORS 設定確保了只有來自您在 `.env` 中指定的 `DOMAIN` 的請求才會被接受。舉例，如果 `DOMAIN=https://myshop.com`，那麼即使有人在 `https://malicious.com` 上寫的 JavaScript 試圖呼叫您的 API，瀏覽器也會基於 CORS 政策直接拒絕該請求。

### 延伸思考：這個機制可以用在哪裡？

**CORS 適用的場景：**
- **社群媒體前後端分離應用**：Instagram 的前端頁面只能呼叫 Instagram 自己的後端 API，駭客無法從釣魚網站盜用您的個人資料
- **企業內部管理系統**：公司的 HR 系統前端只能向公司內部 API 發送請求，防止外部惡意網站竊取員工資料
- **線上課程平台**：學員觀看課程的網頁，只能向該平台的伺服器請求影片資源，防止盜連或資源外流

**關鍵啟示：** CORS 像是機場的「登機口管制」，只有拿著正確航空公司登機證的乘客，才能進入該航空公司的登機口。在前後端分離的架構中，CORS 確保只有來自「合法前端網域」的請求才能存取您的後端資源。

### 真實案例 (Real Case)

#### CORS 配置不當導致的資料洩露

2013 年，許多電商網站因為過度開放 CORS 設定（如設為 `origin: '*'`），導致跨站請求可以任意存取敏感 API。攻擊者可以：
1. 製作一個釣魚網站，看起來像正常的登入頁面
2. 網頁背景中偷偷請求目標電商的 `/api/user-profile` 或 `/api/orders` 端點
3. 由於 CORS 配置過度寬鬆，瀏覽器直接允許請求，攻擊者就取得了使用者的訂單歷史、地址等敏感資料

**參考資料：** [OWASP CORS 安全最佳實踐](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)

#### 真實金流應用場景

支付平台（如 Stripe、PayPal）都嚴格限制 CORS：
- 只允許特定的前端域名發起 API 請求
- 任何來源為 `null` 或未授權的請求會直接被拒絕
- Webhook 回呼則透過簽名驗證而非 CORS

這就是為什麼我們的設定中，將 CORS 域名與環境變數 `DOMAIN` 綁定——確保只有您自己的生產網址能存取後端 API。

### 業界背景 (Industry Context)

CORS 安全配置已成為：
- **PCI DSS 第 6.5.10 條**：要求應用必須「驗證所有信任邊界」，CORS 恰好是前後端間的信任邊界
- **OWASP API 安全 Top 10**：No.5 項強調「不當的資源存取控制」，CORS 是第一層防禦
- **支付閘道商業規範**：Payuni、Stripe 等都要求客戶實現明確的 CORS 政策

#### ⚠️ 常見錯誤 / 誤解

- **偷懶寫 `origin: '*'`**：金流或任何需要帶憑證的 API 避免用萬用字元，安全性會有影響、降低攻擊成本。
- **忘記限制 HTTP 方法與 Headers**：預設放行所有方法，會讓惡意網站有機會嘗試 PUT/DELETE 等敏感操作。

---

## 3. CSRF (跨站請求偽造) - 保護使用者操作的真實性

**是什麼？**
CSRF 是一種常見的攻擊，攻擊者在自己的網站上放置一個陷阱（例如，一張看不見的圖片或一個表單），誘騙已在您網站登入的使用者點擊。一旦點擊，使用者的瀏覽器就會在不知情的情況下，向您的伺服器發送一個惡意請求（例如，更改密碼、下訂單）。

**在此專案中，我們如何防禦？**
我們採用了 `csurf` (或類似的 Token-Based 機制)。

1.  當使用者載入您的頁面時，伺服器會產生一個獨一無二、不可預測的 `CSRF Token`。
2.  前端在發起任何會改變狀態的請求（如 `POST` 請求去建立訂單）時，必須在請求中附上這個 Token。
3.  後端在收到請求時，會驗證這個 Token 是否匹配。如果 Token 不存在或不正確，請求將被拒絕。

**為什麼這很重要？**
由於惡意網站無法得知這個獨一無二的 Token，因此它無法偽造出一個能通過驗證的請求。這確保了每一個重要操作，都是由使用者在您的網站上親自發起的。

**在金流實戰包中的實例**
當使用者在 [01_SYSTEM_ARCHITECTURE.md](./01_SYSTEM_ARCHITECTURE.md) 的「流程二」點擊「立即購買」時，前端會：

1. 從伺服器取得最新的 CSRF Token（在頁面載入時）
2. 在 POST 至 `/api/create-order` 時，將此 Token 附在請求中
3. 後端驗證 Token 是否正確，只有通過驗證才會建立訂單

這確保了訂單一定是使用者親自在您的網站上點擊「購買」按鈕發起的，而不是被其他網站的陷阱誘騙。

### 延伸思考：這個機制可以用在哪裡？

**CSRF 保護適用的場景：**
- **電子商務網站**：防止駭客在釣魚網站放置「一鍵購買」按鈕，嘗試對已登入用戶進行高風險操作
- **社群媒體平台**：防止惡意網站偽造「發布貼文」或「刪除帳號」的請求，保護用戶內容安全
- **網路銀行系統**：確保每一筆轉帳都是用戶在銀行官網親自操作，而非被釣魚網站騙取

**關鍵啟示：** CSRF Token 像是「手寫簽名」，每次重要操作都需要一個只有您和銀行知道的獨特簽名。即使駭客知道您的帳號密碼（Session），沒有這個即時產生的簽名，也無法代替您執行操作。任何涉及「狀態改變」的操作（新增、修改、刪除），都應該用 CSRF 保護。

### 真實案例 (Real Case)

#### 2008 年 uTorrent CSRF 蠕蟲事件

2008 年初，駭客發現 uTorrent 客戶端存在 CSRF 漏洞。攻擊者製作了一個釣魚網站，使用者訪問時，網站會自動向 uTorrent 本地埠發送一個看似無害的請求，將下載位置改為存放惡意軟體的伺服器。用戶毫不知情，最終下載了被感染的檔案。這是 CSRF 導致大規模惡意軟體傳播的經典案例。

**參考資料：** [uTorrent CSRF 漏洞報告 (2008)](https://www.ghacks.net/2008/01/17/dos-vulnerability-in-utorrent-and-bittorrent/)

#### 銀行轉帳的 CSRF 風險

許多銀行過去只依靠 Session Cookie 驗證。攻擊者可以：
1. 製作釣魚網站「恭喜您贏得 100 萬元，點擊領取」
2. 後台隱藏一個表單或 JavaScript，向銀行發起轉帳請求
3. 如果使用者已在銀行登入，瀏覽器會自動帶著有效的 Session Cookie，轉帳請求直接被銀行接受

**結果：** 大筆金錢被轉出，而使用者毫無防備。

現代銀行系統都已加入 CSRF Token 驗證，確保每筆轉帳都需要使用者在銀行官網親自授權。

### 業界背景 (Industry Context)

CSRF 防禦已成為：
- **OWASP Top 10 A01:2021** - 「損壞的存取控制」的重要組成部分
- **PCI DSS 第 6.5.9 條**：明確要求實施 CSRF 防護機制
- **RFC 7231 & RFC 7302**：HTTP 規範層面推薦的幂等性設計（GET 不改變狀態，POST/PUT/DELETE 必須驗證）

在支付流程中，CSRF Token 是確保訂單由真實用戶發起的關鍵。未有 Token，駭客可以代表使用者發起購買，導致誤扣費用或法律糾紛。

#### ⚠️ 常見錯誤 / 誤解

- **把 Token 存在 localStorage**：Token 應該由伺服器產生與維護，存在 localStorage 或 sessionStorage 會被 XSS 輕鬆竊取。
- **整頁快取**：若 CDN 快取含有 CSRF Token 的頁面，會導致所有訪客拿到同一組 Token，等同於失效。
- **只在部分路由檢查**：任何改變伺服器狀態的 POST/PUT/DELETE 都要檢查 Token，尤其是新增的後台功能，很容易忘記套用中介層。

---

## 4. Session 安全管理 - 保護使用者的登入狀態

**是什麼？**
我們使用 `express-session` 來管理使用者登入後的狀態。但僅僅能用是不夠的，安全的設定至關重要。

**我們的安全設定：**

- **`secret: process.env.SESSION_SECRET`**: 用於簽名 Session ID Cookie 的密鑰。一個長且隨機的密鑰可以防止攻擊者偽造 Session。這就是為什麼我們一再強調 `SESSION_SECRET` 的重要性。
- **`cookie.httpOnly: true`**: 此設定禁止客戶端的 JavaScript 存取 Session Cookie。這能有效防禦 XSS 攻擊者竊取使用者的 Session。
- **`cookie.secure: true`** (在正式環境中): 此設定確保 Session Cookie 只在 HTTPS 連線下被傳輸，防止在不安全的 HTTP 連線中被竊聽。
- **`cookie.sameSite: 'strict'`**: 這是防禦 CSRF 的另一道重要防線，它告訴瀏覽器完全不要在跨站請求中發送此 Cookie。

**在金流實戰包中的實例**
在 [01_SYSTEM_ARCHITECTURE.md](./01_SYSTEM_ARCHITECTURE.md) 的「流程一」中，使用者透過 Google OAuth 登入後，後端建立一個 Session 並發送給前端一個加密的 Session Cookie。在之後的每次請求中（如下訂單、檢查登入狀態），前端會自動附上這個 Cookie。我們的安全設定確保了：

1. 即使攻擊者透過 XSS 執行了 JavaScript，也無法透過 `document.cookie` 讀取此 Session（因為 `httpOnly: true`）
2. 在線上環境中，Session 只在 HTTPS 下傳輸，不會在 HTTP 中洩露
3. 即使攻擊者從其他網站試圖偽造請求，瀏覽器也不會自動附上 Session Cookie（因為 `sameSite: 'strict'`）

### 延伸思考：這個機制可以用在哪裡？

**Session 安全管理適用的場景：**
- **會員制網站**：購物網站記住「您已登入」的狀態，讓您在瀏覽商品時不需重複登入
- **線上學習平台**：記錄學員的學習進度和已觀看的課程章節
- **專案管理工具**：記住團隊成員的身份和權限，確保只有授權人員能查看敏感專案資料

**關鍵啟示：** Session 像是遊樂園的「手環」，入園時工作人員給您一個獨特的手環，之後您玩每個設施時只需出示手環即可，不用每次都重新買票。`httpOnly` 確保手環無法被偷走，`secure` 確保手環只在安全通道傳遞，`sameSite` 確保手環只在本遊樂園內有效。任何需要「記住使用者狀態」的應用，都應該用這些設定保護 Session。

### 真實案例 (Real Case)

#### 2017 年 Equifax 資料外洩——Session 管理失敗的後果

2017 年 5 月至 7 月，美國信用評分機構 Equifax 遭到駭客入侵，泄露了 **1.47 億美國人、1520 萬英國人** 的個人資訊（姓名、社會安全號碼、出生日期、地址等）。

**根本原因是什麼？**
1. **未及時更新 Apache Struts**：漏洞在 3 月公開，但 Equifax 直到 5 月被攻擊時仍未修補
2. **預設帳號密碼**：內部系統使用 `admin/admin` 作為預設憑證，未改更
3. **缺乏多因素認證**：高權限帳戶沒有 MFA 保護
4. **Session 管理不當**：攻擊者獲取內部員工的 Session 後，可直接查詢敏感資料庫
5. **加密不足**：部分個人資訊儲存時未適當加密，即使被竊取也能直接讀取

**駭客是如何持續隱藏 76 天的？**
- 竊取員工的有效 Session Cookie 後，以「已授權使用者」身份存取系統
- 系統日誌未檢測出異常查詢行為（因為來自「內部」）
- 駭客使用加密通道隱藏痕跡，直到 7 月才被發現

**後果：**
- Equifax 支付 **6.75 億美元** 和解金
- CEO 被迫辭職
- 英國金融管理局罰款 **£1116 萬**
- 數百起集體訴訟至今仍在進行

**參考資料：** [Equifax 2017 資料外洩詳細分析 (Wikipedia)](https://en.wikipedia.org/wiki/2017_Equifax_data_breach)、[MIT Sloan 學術研究](https://ssrn.com/abstract=3957272)

#### Session 安全配置的實際意義

Equifax 案例中，若他們使用：
- **`httpOnly: true`** → 即使 XSS 發生，內部系統也無法直接竊取 Session Cookie
- **`secure: true`** → 只在 HTTPS 傳輸，防止網路竊聽
- **`sameSite: 'strict'`** → 防止 CSRF 導致無辜員工被代理執行惡意操作
- **定期重新驗證高權限操作** → 即使 Session 被竊，也不能長期保持有效

這些措施可以大幅減少駭客從竊取一個 Session 到執行大規模資料竊取之間的窗口。

### 業界背景 (Industry Context)

Session 安全已成為：
- **OWASP Top 10 A07:2021 - 身份驗證缺陷**：Session 管理不當是導致身份驗證失敗的主要原因
- **PCI DSS 第 8 條**：明確要求實施強身份驗證和會話管理
- **支付卡行業標準**：所有處理支付的應用都必須實施這些 Session 保護措施
- **NIST 網路安全框架**：將 Session 管理列為「身份驗證與授權」層的核心控制

在支付系統中，Session 直接關係到「這筆交易是由真實用戶親自授權的」這個最基本的假設。Session 洩露 = 身份被冒充 = 金錢被盜用。

#### ⚠️ 常見錯誤 / 誤解

- **使用隨便的 `SESSION_SECRET`**：太短或硬編碼在 repo 中的密鑰，等同邀請他人偽造 Session。
- **忘記在 Proxy 後啟用 `trust proxy`**：部署在 Zeabur 或其他平台時，若未設定 `app.set('trust proxy', 1)`，`cookie.secure` 可能判斷錯誤。
- **把 Session 存在預設記憶體 store**：`express-session` 的 MemoryStore 只適合開發環境，正式環境應改用 Redis 等集中式儲存，避免重啟就讓所有人被登出。

---

## 5. AES-256-GCM 加密 (`utils/crypto.js`) - 保護您的敏感資料

**是什麼？**
AES 是當今最安全的對稱加密標準之一。`256` 代表其金鑰長度，強度極高。而 `GCM` (Galois/Counter Mode) 模式則更進一步，它在加密的同時加入了「身份驗證」，確保資料在傳輸過程中不僅未被竊聽，也未被篡改。

**重要提示**
AES-256-GCM 不只是我們的選擇，它是 **Payuni 金流平台指定的加密標準**。當您與 Payuni 通訊時（特別是在流程二和流程三中），必須使用 AES-256-GCM 進行加密與解密。這個實戰包中的 `utils/crypto.js` 已經為您實現了符合 Payuni 規格的加密/解密邏輯。

**您可以用它來做什麼？**
`utils/crypto.js` 中為您封裝了易於使用的 `encrypt` 和 `decrypt` 函式。您可以利用它們來：

- 在將資料發送到第三方服務（如 Payuni）前，對部分敏感欄位進行加密。
- 在資料庫中儲存某些敏感資訊（例如 API 金鑰）時，對其進行加密儲存。
- 保護 Webhook 傳輸的資料。

> **這就像是為您的核心資料提供了一個無法破解的保險箱，並在每次開鎖時都驗證指紋，確保其完整性。**

**在金流實戰包中的實例**
在 [01_SYSTEM_ARCHITECTURE.md](./01_SYSTEM_ARCHITECTURE.md) 的「流程二」和「流程三」中，加密是關鍵：

- **流程二**：當前端要向 Payuni 發起支付時，後端使用 AES-256-GCM 加密訂單資料，產生 `TradeInfo`（加密後的訂單）與 `TradeSha`（簽名），確保 Payuni 收到的資訊完整且未被竄改。
- **流程三**：當 Payuni 的伺服器發送 Webhook 通知時，後端使用 `utils/crypto.js` 中的解密函式，驗證 Webhook 內容的真實性和完整性。如果任何資料被篡改或簽名不正確，解密會失敗，訂單不會被認可為成功。

這確保了整個交易過程中，關鍵的金流資料始終處於加密保護之下，即使網路被中間人攔截也無法看到或篡改內容。

### 延伸思考：這個機制可以用在哪裡？

**AES-256-GCM 加密適用的場景：**
- **雲端檔案儲存服務**：Dropbox 或 Google Drive 在上傳敏感文件前先加密，確保即使雲端伺服器被駭，資料也無法被讀取
- **醫療資訊系統**：醫院與保險公司交換病患資料時加密，符合 HIPAA 等醫療隱私法規
- **物聯網設備通訊**：智慧家電與手機 App 之間的通訊加密，防止駭客竊聽或偽造控制指令

**關鍵啟示：** AES-256-GCM 像是「軍事級保險箱 + 防拆封條」的組合。不僅資料被鎖在保險箱裡（加密），還有防拆封條確保沒有人偷偷打開過（身份驗證）。任何需要與第三方服務安全通訊的場景，或需要儲存高敏感資料時，都應該使用這種「加密 + 驗證」的雙重保護。

### 業界背景 (Industry Context)

#### PCI DSS 加密要求

支付卡行業數據安全標準（PCI DSS）在其 **第 3 條 - 保護持卡人資料** 中明確規定：

> **要求 3.4：** 如果採用加密方式保護持卡人資料，則應在儲存期間和傳輸中使用 NIST 認可的加密方法或更強的方法。

- **NIST 認可的方法**：AES-256、3DES（已過時）、ECC-256 或更高
- **GCM 模式**：在 PCI DSS 最新版本中被特別推薦，因其兼具加密 + 身份驗證

**換句話說**：如果您要處理信用卡資訊或與支付平台通訊，PCI DSS 強制要求您必須使用像 AES-256-GCM 這樣的加密標準。不符合要求不只違反標準，還可能導致監管罰款。

#### Payuni 的強制要求

作為本實戰包的支付整合平台，Payuni 對 `TradeInfo` 和 `TradeSha` 的計算有嚴格要求：
- 必須使用 AES-256-GCM 加密
- 必須使用特定的金鑰和初始化向量 (IV) 格式
- 簽名順序和字元編碼必須完全吻合

**為什麼這麼嚴格？** 因為 Payuni 需要 100% 確信收到的訂單資訊完全來自您的系統，未被篡改。一丁點偏差就意味著交易可能被拒絕或被視為欺詐。

#### 金融產業標準

- **美國 HIPAA（醫療隱私法）**：要求敏感醫療資訊必須使用 AES-256 或同等級加密
- **歐盟 GDPR**：強調「適當的技術措施」保護個人資訊，AES-256-GCM 被廣泛認可為適當措施
- **中國 GB/T 32960 (電動汽車資訊安全)** 和其他地方法規：都指定 AES 為標準加密方法

簡言之，**AES-256-GCM 不是我們的選擇，而是全球金融與隱私保護的強制標準**。

#### ⚠️ 常見錯誤 / 誤解

- **重複使用同一組 IV**：GCM 模式必須為每次加密產生新的 Initialization Vector，否則加密強度大幅下降。
- **把 `HashKey` / `HashIV` 寫進程式碼庫**：金鑰應只存在 `.env` 或密鑰管理服務，否則版本控管會留下永久紀錄。
- **混用不同的編碼/排序**：Payuni 的 `TradeSha` 計算對大小寫、欄位順序極度敏感，請確保 `utils/crypto.js` 的邏輯未被擅自修改。

---

## 重點回顧

讀完本文後，您應該理解了：

- **Helmet** 為什麼能透過 HTTP 標頭防止 XSS、點擊劫持等常見攻擊
- **CORS** 為什麼只允許來自自己網站的前端請求您的 API
- **CSRF Token** 為什麼能防止惡意網站代表使用者發起請求
- **Session 安全設定** 中每一項參數（`httpOnly`、`secure`、`sameSite`）的具體用途
- 什麼時候應該用 **AES-256-GCM 加密**、它怎麼同時保證機密性和完整性

這些機制並非個別獨立，而是彼此配合，形成一個**多層防禦體系**。

---

## 下一步

| 如果你想...    | 推薦閱讀                                                                               |
| -------------- | -------------------------------------------------------------------------------------- |
| 客製化這套方案 | [03_CUSTOMIZATION_GUIDE.md](./03_CUSTOMIZATION_GUIDE.md)                               |
| 部署到線上環境 | [04_DEPLOYMENT.md](./04_DEPLOYMENT.md)                                                 |
| 複習系統流程   | 回到 [01_SYSTEM_ARCHITECTURE.md](./01_SYSTEM_ARCHITECTURE.md) 看各流程如何應用這些防護 |
| 還有其他疑問   | 參考 [00_DESIGN_PHILOSOPHY.md](./00_DESIGN_PHILOSOPHY.md) 了解整體思考邏輯             |

### 最後提醒

安全不是一次性的工作，而是持續的責任。當您客製化或擴充功能時，請務必：

1. **不要移除或禁用任何現有的安全機制**，除非您完全理解其影響
2. **為新增功能套用相同的防護原則**
3. **定期檢查 `.env` 文件**，確保所有金鑰都是強隨機字符串且不被外洩

> 📌 **定位補述**：本份安全深度解析已與 `AI_OUTPUTS/Pivoted_Payment_Gateway_Strategy.md` 的能力導向策略同步，未來如要新增安全主題，請先對照該報告確保語氣與重點仍在「教學優先、能力為主」的框架內。

您的使用者信任您；請用這些工具好好保護他們。
